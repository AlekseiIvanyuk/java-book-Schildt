<small>

## Java полное руководство - Герберт Шилдт, 10-е издание, 2018.

### (*По ходу изучения Java по книге, тут сохранены основные моменты с примерами кода*)

<details><summary>ГЛАВА 1. "История и развитие языка Java"</summary>


>**Версия Java SE 9**    
>Главным нововведением в версии JDK 9 являются модули, позволяющие указывать взаимосвязи и зависимости в прикладном коде, а также расширяющие возможности управления доступом в Java. Вместе с модулями в языке Java появился
новый синтаксический элемент и несколько ключевых слов. Кроме того, в состав JDK была включена утилита j link, позволяющая создавать на стадии выполнения образ прикладного файла типа JMOD, содержащего только нужные модули.
Модули также оказали заметное влияние на библиотеку Java API, поскольку, начиная с версии JDK 9, библиотечные пакеты организованы в модули.
>
</details>

<details><summary>ГЛАВА 2. "Краткий обзор Java"</summary>  

>**Абстракция**  
>Важным элементом ООП является абстракция. Человеку свойственно представлять сложные явления и объекты, прибегая к абстракции. Например, люди
 представляют себе автомобиль не в виде набора десятков тысяч отдельных деталей, а в виде совершенно определенного объекта, имеющего свое особое поведение. Эта абстракция позволяет не задумываться о сложности деталей, составляющих автомобиль, скажем, при поездке в магазин. Можно не обращать внимания
 на подробности работы двигателя, коробки передач и тормозной системы. Вместо этого объект можно использовать как единое целое.
>
>Эффективным средством применения абстракции служат иерархические классификации. Это позволяет упрощать семантику сложных систем, разбивая их на более управляемые части. Внешне автомобиль выглядит единым объектом. Но
 стоит заглянуть внутрь, как становится ясно, что он состоит из нескольких подсистем: рулевого управления, тормозов, аудиосистемы, привязных ремней, обогревателя, навигатора и т.п. Каждая из этих подсистем, в свою очередь, собрана из более
 специализированных узлов. Например, аудиосистема состоит из радиоприемника, проигрывателя компакт-дисков и/или аудиокассет. Суть всего сказанного состоит в том, что структуру автомобиля (или любой другой сложной системы) можно
 описать с помощью иерархических абстракций.
>
> Иерархические абстракции сложных систем можно применять и к компьютерным программам. Благодаря абстракции данные традиционной, ориентированной
 на процессы, программы можно преобразовать в составляющие ее объекты, а последовательность этапов процесса - в совокупность сообщений, передаваемых
 между этими объектами. Таким образом, каждый из этих объектов описывает свое
 особое поведение. Эти объекты можно считать отдельными сущностями, реагирующими на сообщения, предписывающие им выполнить конкретное действие.
 В этом, собственно, и состоит вся суть ООП.  
>
>Принципы ООП лежат как в основе языка Java, так и восприятия мира человеком. Важно понимать, каким образом эти принципы реализуются в программах. Как станет ясно в дальнейшем, ООП является еще одной, но более эффективной и естественной
 парадигмой создания программ, способных пережить неизбежные изменения, сопровождающие жизненный цикл любого крупного программного проекта, включая зарождение общего замысла, развитие и созревание. Например, при наличии тщательно
 определенных объектов и ясных, надежных интерфейсов с этими объектам можно безбоязненно и без особого труда извлекать или заменять части старой системы.
>
>**Инкапсуляция**  
>Механизм, связывающий код и данные, которыми он манипулирует, защищая оба эти компонента от внешнего вмешательства и злоупотреблений, называется инкапсуляцией. Инкапсуляцию можно считать защитной оболочкой, которая предохраняет код и данные от произвольного доступа со стороны другого кода, находящегося
 снаружи оболочки. Доступ к коду и данным, находящимся внутри оболочки, строго контролируется тщательно определенным интерфейсом. Чтобы провести аналогию с реальным миром, рассмотрим автоматическую коробку передач автомобиля.
 Она инкапсулирует немало сведений об автомобиле, в том числе величину ускорения, крутизну поверхности, по которой совершается движение, а также положение рычага переключения скоростей. Пользователь (в данном случае водитель) может оказывать влияние на эту сложную инкапсуляцию только одним способом: перемещая рычаг переключения скоростей. На коробку передач нельзя воздействовать,
 например, с помощью индикатора поворота или дворников. Таким образом, рычаг переключения скоростей является строго определенным, а по существу, единственным интерфейсом с коробкой передач. Более того, происходящее внутри коробки
 передач не влияет на объекты, находящиеся вне ее. Например, переключение передач не включает фары! Функция автоматического переключения передач инкапсулирована, и поэтому десятки изготовителей автомобилей могут реализовать ее как
 угодно. Но с точки зрения водителя все эти коробки передач работают одинаково.
>
>Аналогичный принцип можно применять и в программировании. Сильная сторона инкапсулированного кода состоит в следующем: всем известно, как получить доступ к нему, а следовательно, его можно использовать независимо о подробностей реализации и не опасаясь неожиданных побочных эффектов.  
>
>Основу инкапсуляции в Java составляет класс. Подробнее классы будут рассмотрены в последующих главах, а до тех пор полезно дать хотя бы краткое их описание.
 Класс определяет структуру и поведение (данные и код), которые будут совместно использоваться набором объектов. Каждый объект данного класса содержит структуру и поведение, которые определены классом, как если бы объект был "отлит"
 в форме класса. Поэтому иногда объекты называют экземплярами класса. Таким образом, класс - это логическая конструкция, а объект - ее физическое воплощение. При создании класса определяются код и данные, которые образуют этот класс.
>
>Совместно эти элементы называются членами класса. В частности, определенные в классе данные называются переменными-членами или переменными экземпляра,
 а код, оперирующий данными, - методами-членами или просто методами. (То, что программирующие на Java называют методами, программирующие на С/С++ называют функциями.) В программах, правильно написанных на Java, методы определяют, 
 60 Часть 1. Язык Java каким образом используются переменные-члены. Это означает, что поведение и интерфейс класса определяются методами, оперирующими данными его экземпляра.  
 Назначение класса состоит в инкапсуляции сложной структуры программы, и поэтому существуют механизмы сокрытия сложной структуры реализации в самом
 классе. Каждый метод или переменная в классе могут быть помечены как закрытые или открытые. Открытый интерфейс класса представляет все, что должны или могут знать внешние пользователи класса. Закрытые методы и данные могут быть доступны только для кода, который является членом данного класса. Следовательно,
 любой другой код, не являющийся членом данного класса, не может получать доступ к закрытому методу или переменной. Закрытые члены класса доступны другим частям программы только через открытые методы класса, и благодаря этому исключается возможность выполнения неправомерных действий. Это, конечно, означает,
 что открытый интерфейс должен быть тщательно спроектирован и не должен раскрывать лишние подробности внутреннего механизма работы класса.
>
>**Наследование**  
>Процесс, в результате которого один объект получает свойства другого, называется наследованием. Это очень важный принцип ООП, поскольку наследование обеспечивает принцип иерархической классификации. Как отмечалось ранее,
 большинство знаний становятся доступными для усвоения благодаря иерархической (т.е. нисходящей) классификации. Например, золотистый ретривер - часть
классификации собак, которая, в свою очередь, относится к классу млекопитающих, а тот - к еще большему классу животных. Без иерархий каждый объект должен был бы явно определять все свои характеристики. Но благодаря наследованию
объект должен определять только те из них, которые делают его особым в классе. Объект может наследовать общие атрибуты от своего родительского объекта.
Таким образом, механизм наследования позволяет сделать один объект частным случаем более общего случая.
> 
>Рассмотрим этот механизм подробнее.   
Как правило, большинство людей воспринимают окружающий мир в виде иерархически связанных между собой объектов, подобных животным, млекопитающим и собакам. Если требуется привести абстрактное описание животных, можно сказать, что они обладают определенными свойствами: размеры, умственные
способности и костная система. Животным присущи также определенные особенности поведения: они едят, дышат и спят. Такое описание свойств и поведения составляет определение класса животных.  
Если бы потребовалось описать более конкретный класс животных, например млекопитающих, следовало бы указать и более конкретные свойства, в частности тип зубов и молочных желез. Такое определение называется подклассом животных, которые относятся к суперклассу (родительскому классу) млекопитающих.
А поскольку млекопитающие - лишь более точно определенные животные, то они наследуют все свойства животных. Подкласс нижнего уровня иерархии классов наследует все свойства каждого из его родительских классов
>
>**Полиморфизм**  
>Полиморфизм (от греч. "много форм") - это принцип ООП, позволяющий использовать один и тот же интерфейс для общего класса действий. Каждое действие
 зависит от конкретной ситуации. Рассмотрим в качестве примера стек, действующий как список обратного магазинного типа. Допустим, в программе требуются
 стеки трех типов: для целочисленных значений, для числовых значений с плавающей точкой и для символов. Алгоритм реализации каждого из этих стеков остается неизменным, несмотря на отличия в данных, которые в них хранятся. В языке,
 не являющемся объектно-ориентированным, для обращения со стеком пришлось бы создавать три разных ряда подпрограмм под отдельными именами. А в языке Java благодаря принципу полиморфизма для обращения со стеком можно определить общий ряд подпрограмм под одними и теми же общими именами.  
 В более общем смысле принцип полиморфизма нередко выражается фразой "один интерфейс, несколько методов': Это означает, что можно разработать общий интерфейс для группы связанных вместе действий. Такой подход позволяет уменьшить сложность программы, поскольку один и тот же интерфейс служит
 для указания общего класса действий. А выбор конкретного действия (т.е. метода) делается применительно к каждой ситуации и входит в обязанности компилятора.
 Это избавляет программиста от необходимости делать такой выбор вручную. Ему нужно лишь помнить об общем интерфейсе и правильно применять его.  
 Если продолжить аналогию с собаками, то можно сказать, что собачье обоняние - полиморфное свойство. Если собака почувствует запах кошки, она залает
 и погонится за ней. А если собака почувствует запах своего корма, то у нее начнется слюноотделение, и она поспешит к своей миске. В обоих случаях действует одно
 и то же чувство обоняния. Отличие лишь в том, что именно издает запах, т.е. в типе данных, воздействующих на нос собаки! Этот общий принцип можно реализовать, применив его к методам в программе на Java. 
>

</details>

<details><summary>ГЛАВА 3. "Типы данных, переменные и массивы"</summary>

>
>>* **Целые числа.**   
>>Тип bуtе 8-разрядный тип данных со знаком от -128 до 127.  
>>Тип short представляет 16-разрядные целочисленные значения со знаком в пределах от -32768 до 32767. Этот тип данных применяется в Java реже всех остальных.  
>>Тип int это тип 32-разрядных целочисленных значений со знаком в пределах от -2147483648 до 2147483647.  
>>Тип long этот тип 64-разрядных целочисленных значений со знаком удобен в тех случаях, когда длины типа int недостаточно для хранения требуемого значения.   

>>* **Числа с плавающей точкой.**  
>>Тип float Этот тип определяет числовое значение с плавающей точкой одинарной точности, для хранения которого в оперативной памяти требуется 32 бита.  
>>Тип doublе Для хранения числовых значений с плавающей точкой двойной точности, как обозначает ключевое слово doublе, в оперативной памяти требуется 64 бита.    

>>* **Символы.**  
>>Эта группа включает в себя тип данных char, представляющий символы, например буквы и цифры, из определенного набора.  

>>* **Тип данных char.**  
>>Символы представлены в Юникоде (Unicode), для хранения этих символов требуется 16 бит, диапазон  от О до 65536.  

>>* **Логические значения.**  
>>Тип boolean, предназначенный для хранения логических значений. Переменные этого типа могут принимать только одно из двух возможных значений: true (истинное) или false (ложное).  

>>**Управляющие последовательности символов**  
>>|Управляющая последовательность|Описание|
>>|:-----------------------------|:-------|
>>|\ddd|Восьмеричный символ ( ddd) |
>>|\uxxxx|Шестнадцатеричный символ в Юникоде (.хххх)|
>>|\'|Одинарная кавычка|
>>|\"|Двойная кавычка|
>>|\\|Обратная косая черта|
>>|\r|Возврат каретки|
>>|\n|Новая строка (или перевод строки)|
>>|\f|Подача страницы|
>>|\t|Табуляция|
>>|\b|Возврат на одну позицию ("забой")|

>>**Область видимости и срок действия переменных**  
>>При открытии каждого нового блока кода создается новая область видимости. Область видимости определяет, какие именно объекты доступны для других частей программы. Она определяет также продолжительность существования этих объектов.
>>  
>>Области видимости могут быть вложенными. Так, вместе с каждым блоком кода, по существу, создается новая, вложенная область видимости. В таком случае внешняя область видимости включает в себя внутреннюю область. Это означает, что объекты, объявленные во внешней области видимости, будут доступны
для кода из внутренней области видимости, но не наоборот. Объекты, объявленные во внутренней области видимости, будут недоступны за ее пределами.
  
>>**Автоматическое преобразование типов в Java**  
>>Когда данные одного типа присваиваются переменной другого типа, выполняется автоматическое преобразование типов, если удовлетворяются два условия:  
>
>>* оба типа совместимы;  
>>* длина целевого типа больше длины исходного типа.  
>
>>**Правила продвижения типов**
>>В языке Java определен ряд правил продвижения типов, применяемых к выражениям. Сначала все значения типа byte, short и char продвигаются к типу int,
  как пояснялось выше. Затем тип всего выражения продвигается к типу long, если
  один из его операндов относится к типу long. Если же один из операндов относится к типу float, то тип всего выражения продвигается к типу float. А если
  любой из операндов относится к типу douЫe, то и результат вычисления всего
  выражения относится к типу douЫe.  
>>
>>[Chapter03/Conversion - Продемонстрировать приведение типов](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/Conversion.java "Посмотреть пример Java")  
>>[Chapter03/Scope - Продемонстрировать область видимости блока кода](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/Scope.java "Посмотреть пример Java")  
>
>>**Массивы**  
>>Массив - это группа однотипных переменных, для обращения к которым используется общее имя. В языке Java допускается создание массивов любого типа
  и разной размерности. Доступ к конкретному элементу массива осуществляется по его индексу. Массивы предоставляют удобный способ группирования связанной вместе информации.  
>>Массивы бывают ОДНОМЕРНЫЕ и МНОГОМЕРНЫЕ.  
>>
>>[Chapter03/Array - Продемонстрировать применение одномерного массива](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/Array.java "Посмотреть пример Java")  
>>[Chapter03/CountDayArray - Усовершенствованная версия предыдущей программы](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/CountDayArray.java "Посмотреть пример Java")   
>>[Chapter03/TwoDArray - Двумерный массив](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/TwoDArray.java "Посмотреть пример Java")  
>>[Chapter03/Matrix - Инициализировать двухмерный массив](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/Matrix.java "Посмотреть пример Java")  
>>[Chapter03/DuoArray - Применение двумерного массива](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/DuoArray.java "Посмотреть пример Java")  
>>[Chapter03/ThreeArray - Пример трехмерного массива](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/ThreeArray.java "Посмотреть пример Java")  
>>[Chapter03/TwoDAgain - Резервирование памяти вручную для массива с разной размерностью второго измерения](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/TwoDAgain.java "Посмотреть пример Java")  
>>[Chapter03/Average - Вычисление среднего из массива значений](https://github.com/aykononov/JavaSchildt/tree/master/Chapter03/TwoDAgain.java "Посмотреть пример Java")  
</details>

<details><summary>ГЛАВА 4. "Операции"</summary>

>
>[Chapter04/BasicMath - Продемонстрировать основные арифметические операции](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/BasicMath.java "Посмотреть пример Java")  
>[Chapter04/Modulus - Операция деления по модулю "%" (возвращает остаток от деления)](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/Modulus.java "Посмотреть пример Java")  
>[Chapter04/OpEquals - Составные операции с присваиванием](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/OpEquals.java "Посмотреть пример Java")  
>
>**Поразрядные операции в Java**  
>"~"    - Поразрядная унарная операция НЕ  
>"&"    - Поразрядная логическая операция И  
>"|"    - Поразрядная логическая операция ИЛИ  
>"^"    - Поразрядная логическая операция исключающее ИЛИ  
>">>"   - Сдвиг вправо  
>">>>"  - Сдвиг вправо с заполнением нулями  
>"<<"   - Сдвиг влево  
>"&="   - Поразрядная логическая операция И с присваиванием  
>"|="   - Поразрядная логическая операция ИЛИ с присваиванием  
>"^="   - Поразрядная логическая операция исключающее ИЛИ с присваиванием  
>">>="  - Сдвиг вправо с присваиванием  
>">>>=" - Сдвиг вправо с заполнением нулями и присваиванием  
>"<<="  - Сдвиг влево с присваиванием  
>
>[Chapter04/BitLogic - Продемонстрировать применение поразрядных логических операций](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/BitLogic.java "Посмотреть пример Java")  
>[Chapter04/HexByte - Маскирование двоичных разрядов расширения знака](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/HexByte.java "Посмотреть пример Java")  
>[Chapter04/ByteShift - Сдвиг влево значения типа byte](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/ByteShift.java "Посмотреть пример Java")  
>[Chapter04/ByteLeft - Сдвиг влево](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/ByteLeft.java "Посмотреть пример Java")  
>
>**Операции отношения(сравнения)**  
>"=="   - Равно  
 "!="   - Не равно  
 ">"    - Больше  
 "<"    - Меньше  
 ">="   - Больше или равно  
 "<="   - Меньше или равно
>
>**Логические операции**  
>&  - Логическая операция И  
 |  - Логическая операция ИЛИ  
 ^  - Логическая операция исключающее ИЛИ  
 || - Укороченная логическая операция ИЛИ  
 && - Укороченная логическая операция И  
 !  - Логическая унарная операция НЕ  
 &= - Логическая операция И с присваиванием  
 |= - Логическая операция ИЛИ с присваиванием  
 ^= - Логическая операция исключающее ИЛИ с присваиванием  
 == - Равенство  
 != - Неравенство  
 ?: - Тернарная условная операция типа если"., то"., иначе".
>
>[Chapter04/Ternary - Продемонстрировать применение тернарной операции "?"](https://github.com/aykononov/JavaSchildt/tree/master/Chapter04/Ternary.java "Посмотреть пример Java")  
  
</details>

<details><summary>ГЛАВА 5. "Управляющие операторы"</summary>

>
>Управляющие операторы применяются для реализации переходов и ветвлений в потоке исполнения команд программы, исходя из ее состояния. Управляющие операторы в программе на Java можно разделить
 на следующие категории: операторы выбора, операторы цикла и операторы перехода. Операторы выбора позволяют выбирать разные ветви выполнения команд
 в соответствии с результатом вычисления заданного выражения или состоянием переменной. Операторы цикла позволяют повторять выполнение одного или нескольких операторов (т.е. они образуют циклы). Операторы перехода обеспечивают возможность нелинейного выполнения программы.
>
>[Chapter05/SampleSwitch - Простой пример применения оператора switch](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/SampleSwitch.java "Посмотреть пример Java")  
>[Chapter05/NoBody - Цикл whilе (целевая часть цикла может быть пустой)](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/NoBody.java "Посмотреть пример Java")  
>[Chapter05/DoWhile - Продемонстрировать применение оператора цикла do-while](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/DoWhile.java "Посмотреть пример Java")  
>[Chapter05/ChoiceMenu - Использовать оператор цикла do-while для выбора пункта меню.](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/ChoiceMenu.java "Посмотреть пример Java")  
>[Chapter05/ForEach - Пример цикла for в стиле for each](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/ForEach.java "Посмотреть пример Java")  
>[Chapter05/ForEachDuoArray - Применение цикла for в стиле for each для обращения к двухмерному массиву](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/ForEachDuoArray.java "Посмотреть пример Java")  
>[Chapter05/BreakWhile - Применение оператора break во вложенных циклах](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/BreakWhile.java "Посмотреть пример Java")  
>[BreakToLabel - Применение оператора Ьreak с меткой для выхода из вложенных циклов.](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/BreakToLabel.java "Посмотреть пример Java")  
>[Chapter05/Continue - Продемонстрировать применение оператора continue](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/Continue.java "Посмотреть пример Java")  
>[Chapter05/Return - Оператор return немедленно прекращает выполнение метода, в теле которого он находится.](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/Return.java "Посмотреть пример Java")  
>[Chapter05/ContinueLabel - Применение оператора continue с меткой](https://github.com/aykononov/JavaSchildt/tree/master/Chapter05/ContinueLabel.java "Посмотреть пример Java")  

</details>

<details><summary>ГЛАВА 6. "Введение в классы"</summary>

>
>**Класс определяет форму и сущность объекта.**  
>Таким образом, Класс - *Это шаблон для создания объекта*, а Объект - *Это экземпляр класса*. 
 Но поскольку Объект является экземпляром Класса, то понятия объект и экземпляр употребляются в одном и том же смысле.  
 При определении Класса объявляется его конкретная форма и сущность. Для этого указываются данные, которые он содержит, а также код, воздействующий на эти данные.
 И хотя очень простые Классы могут содержать только код или только данные, большинство классов, применяемых в реальных программах, содержат оба компонента.  
 Данные, или переменные, определенные в классе, называются переменными экземпляра. Код содержится в теле методов. Вместе с переменными зкземпляра
 методы, определенные в классе, называются цленами класса. В большинстве классов действия над переменными зкземпляра и доступ к ним осуществляют методы,
 определенные в этом классе. Таким образом, именно методы, как правило, определяют порядок использования данных класса.  
 Как упоминалось выше, переменные, определенные в классе, называются переменными экземпляра, поскольку каждый экземпляр класса (т.е. каждый объект
 класса) содержит собственные копии этих переменных. Таким образом, данные одного объекта отделены и отличаются от данных другого объекта.  
 Все методы имеют ту же общую форму, что и метод main(), но большинство методов редко объявляются как static или public.  
>
> *В общей форме класса отсутствует определение метода main(). Его нужно указывать только в тех случаях, когда данный класс служит отправной точкой для выполнения программы.*
>
>[Chapter06/BoxDemo - Программа, использующая класс Box](https://github.com/aykononov/JavaSchildt/tree/master/Chapter06/BoxDemo.java "Посмотреть пример Java")  
>[Chapter06/BoxDemo2 - В этой программе объявляются два объекта класса Вох](https://github.com/aykononov/JavaSchildt/tree/master/Chapter06/BoxDemo2.java "Посмотреть пример Java")  
>[Chapter06/BoxDemo3 - В этой программе применяется метод с параметрами](https://github.com/aykononov/JavaSchildt/tree/master/Chapter06/BoxDemo3.java "Посмотреть пример Java")  
>[Chapter06/BoxDemo4 - В классе Box4 применяется параметрзованный конструктор](https://github.com/aykononov/JavaSchildt/tree/master/Chapter06/BoxDemo4.java "Посмотреть пример Java")  
>[Chapter06/BoxDemo5 - Перегрузка методов](https://github.com/aykononov/JavaSchildt/tree/master/Chapter06/BoxDemo5.java "Посмотреть пример Java")  
>[Chapter06/Stack - Реализация класса Stack](https://github.com/aykononov/JavaSchildt/tree/master/Chapter06/Stack.java "Посмотреть пример Java")  
>[Chapter06/TestStack - Применение класса Stack](https://github.com/aykononov/JavaSchildt/tree/master/Chapter06/TestStack.java "Посмотреть пример Java")  

</details>

<details><summary>ГЛАВА 7. "Подробное рассмотрение классов и методов"</summary>

><details><summary>Перегрузка методов</summary>
>
>Далее будет продолжено более подробное рассмотрение методов и классов на следующих примерах:  
>Перегрузка методов поддерживает полиморфизм, поскольку это один из способов реализации в Java принципа "один интерфейс, несколько методов. 
>В тех языках программирования, где перегрузка методов не поддерживается, каждому методу должно быть присвоено однозначное имя. Но зачастую требуется реализовать, по существу, один и тот же метод для разных типов данных.  
>Перегрузка методов ценна тем, что позволяет обращаться к похожим методам по общему имени.
>  
>Выбор подходящего варианта метода для кQнкретной ситуации входит в обязанности компилятора, а программисту нужно лишь запомнить общее выполняемое действие. Полиморфизм позволяет свести несколько имен к одному.  
>При перегрузке метода каждый его вариант может выполнять любые требующиеся действия. Не существует правила, согласно которому перегружаемые методы должны быть связаны друг с другом.
>  
>[Chapter07/OverloadDemo - Продемонстрировать перегрузку методов](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/OverloadDemo.java "Посмотреть пример Java")  
>[Chapter07/OverloadDemo2 - Применить автоматическое преобразование типов к перегрузке](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/OverloadDemo.java "Посмотреть пример Java")  
>
>Наряду с перегрузкой обычных методов можно также выполнять перегрузку методов-конструкторов.  
>В качестве параметров объекты чаще всего употребляются в конструкторах.
 Нередко новый объект приходится создавать таким образом, чтобы он первоначально ничем не отличался от уже существующего объекта. Для этого придется
 определить конструктор, принимающий в качестве параметра объект своего класса. Например, приведенная ниже очередная версия класса Вох позволяет инициализировать один объект другим.  
>
>[Chapter07/BoxDemo01 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/BoxDemo01.java "Посмотреть пример Java")  
>
></details>

><details><summary>Передача агрументов - Вызов по значению</summary>
>
>В этом случае значение аргумента копируется в формальный параметр подпрограммы. Следовательно, изменения, вносимые в параметр подпрограммы, не оказывают никакого влияния на аргумент.  
>*Когда методу передается аргумент примитивного типа, его передача происходит по значению. В итоге создается копия аргумента, и все, что происходит с параметром, принимающим этот аргумент, не оказывает никакого влияния за пределами вызываемого метода.*  
>[Chapter07/CallByValue02 - Аргументы примитивных типов передаются по значению](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/CallByValue02.java "Посмотреть пример Java")  
>
></details>

><details><summary>Передача объектов</summary>
>
>При передаче объекта в качестве аргумента методу ситуация меняется коренным образом, поскольку объекты, по существу, передаются при вызове по ссылке. Не следует, однако, забывать, что *при объявлении переменной типа класса создается лишь ссылка на объект этого класса.*  
 Таким образом, при передаче этой ссылки методу принимающий ее параметр будет ссылаться на тот же самый объект, на который ссылается и аргумент. По существу, это означает, что объекты действуют так, как будто они передаются методам по ссылке. Но изменения объекта в теле метода оказывают влияние на объект, указываемый в качестве аргумента.  
[Chapter07/CallObjLink03 - Объекты передаются по ссылке на них](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/CallObjLink03.java "Посмотреть пример Java")  
>
></details>

><details><summary>Возврат объектов</summary>
>
>Метод может возвращать любой тип данных, в том числе созданные типы классов.  
 При каждом вызове метода в программе создается новый объект, а ссылка на него возвращается вызывающей части программы. 
 В данной программе демонстрируется еще один важный момент: память выделяется для всех объектов динамически с помощью операции new, а следовательно, программисту не нужно принимать никаких мер, чтобы объект не вышел за пределы области своего действия, поскольку выполнение метода, в котором он был создан, прекращается. Объект будет
 существовать до тех пор, пока будет существовать ссылка на него в каком-нибудь другом месте программы.  
 В отсутствие любых ссылок на объект он будет уничтожен при последующей сборке "мусора".  
>В приведенном ниже примере проrраммы метод icrByTen() возвращает объект, в котором значение переменной а на "1О" больше значения этой переменной в вызывающем объекте:  
>[Chapter07/ReturnObject04 - Возврат объекта](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/ReturnObject04.java "Посмотреть пример Java")  
></details>

><details><summary>Рекурсия</summary>
>
>Процесс определения чего-либо относительно самого себя называется Рекурсией. В Java Рекурсия - это средство, которое позволяет методу вызывать самого себя.   
>Такой метод называется *Рекурсивным*.  
>Когда рекурсивный метод вызывает сам себя, новым локальным переменным и параметрам выделяется место в стеке и код метода выполняется с этими новыми исходными значениями. 
 При каждом возврате из вызова рекурсивного метода прежние локальные переменные и параметры удаляются из стека, а выполнение продолжается с точки вызова в самом методе. 
>Рекурсивные методы выполняют действия, которые можно сравнить с раскладыванием и складыванием телескопической трубы.
>  
>Недостаток:  
>Слишком большое количество вызовов рекурсивного метода может привести к переполнению стека, поскольку параметры и локальные переменные сохраняются в стеке,
 а при каждом новом вызове создаются новые копии этих значений. В таком случае в исполняющей системе Java возникнет исключение.
>  
>Преимущество:  
>Главное преимущество рекурсивных методов заключается в том, что их можно
 применять для реализации более простых и понятных вариантов некоторых алгоритмов, чем их итерационные аналоги. Например, алгоритм быстрой сортировки
 очень трудно реализовать итерационным способом. А некоторые виды алгоритмов, связанных с искусственным интеллектом, легче всего реализовать с помощью рекурсивных решений.
>  
>Важно!!!  
>При написании рекурсивных методов следует позаботиться о том, чтобы в каком-нибудь другом месте программы присутствовал условный оператор i f, осуществляющий возврат из метода без его рекурсивного вызова. В противном случае возврата из рекурсивно вызываемого метода так и не произойдет. 
>Подобная ошибка очень часто встречается при организации рекурсии. Поэтому на стадии разработки рекурсивных методов рекомендуется как можно чаще делать вызовы метода println(),чтобы следить за происходящим и прерывать выполнение при обнаружении ошибки.
>  
>*Классическим примером рекурсии служит вычисление факториала числа.*  
>Факториал числа N - это произведение всех целых чисел от 1 до N.   
 Например, факториал числа 3 равен 1*2*3, т.е. 6.  
>Ниже показано, как вычислить факториал, используя рекурсивный метод:  
>[Chapter07/Recursion05 - Простой пример рекурсии (вычисление Факториала)](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/Recursion05.java "Посмотреть пример Java")  
>[Chapter07/Recursion06 - Еще один пример рекурсии](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/Recursion06.java "Посмотреть пример Java")  
></details>

><details><summary>Управление доступом</summary>
>
>Инкапсуляция позволяет управлять доступом к членам класса из отдельных частей программы.  
>В языке Java определяются следующие модификаторы доступа: *рublic (открытый), private (закрытый)* и *protected (защищенный)*, а также уровень доступа, предоставляемый по умолчанию. Модификатор доступа protected применяется только при наследовании.
>  
>Когда член объявляется с модификатором доступа *рublic*, он становится доступным из любого
 другого кода. А когда член класса объявляется с модификатором доступа *private*,
 он доступен только другим членам этого же класса. Теперь становится понятно,
 почему в объявлении метода **main()** всегда присутствует модификатор *рublic*.
 Этот метод вызывается из кода, находящегося за пределами данной программы, т.е. из исполняющей системы Java. 
 В отсутствие модификатора доступа по умолчанию член класса считается открытым в своем пакете, но недоступным для кода, находящегося за пределами этого пакета.  
>
>В следующем примере демонстрируется отличие модификаторов *рublic и private*:  
>[Chapter07/TestAccess07 - Демонстрация модификаторов доступа](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/TestAccess07.java "Посмотреть пример Java")  
>В качестве более реального примера организации управления доступом рассмотрим следующую усовершенствованную версию класса Stack.  
>[Chapter07/StackTest08 - Пример, усовершенствованной версии класса Stack](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/StackTest08.java "Посмотреть пример Java")  
></details>

><details><summary>Ключевое слово static</summary>
>
>Когда член класса объявлен как *static (статический)*, он доступен до создания любых объектов его класса и без ссылки на какой-нибудь объект. 
 Статическими могут быть объявлены как методы, так и переменные. Наиболее распространенным примером статического члена служит метод **main()**, который объявляется как *static*,
 поскольку он должен быть объявлен до создания любых объектов.
 Переменные экземпляра, объявленные как *static*, по существу, являются глобальными. При объявлении объектов класса этих переменных их копии не создаются. Вместо этого все экземпляры класса совместно используют одну и ту же
 статическую переменную.
>  
>На методы, объявленные как *static*, налагаются следующие ограничения:
>* Они могут непосредственно вызывать только другие статические методы.
>* Им непосредственно доступны только статические переменные.
>* Они никоим образом не могут делать ссылки типа *this* или *super*.  
>
>Если для инициализации статических переменных требуется произвести вычисления, то для этой цели достаточно объявить статический блок, который будет выполняться только один раз при первой загрузке класса.   
>В приведенном ниже примере демонстрируется класс, который содержит статический метод, несколько статических переменных и статический блок инициализации.  
>[Chapter07/UseStatic09 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/UseStatic09.java "Посмотреть пример Java")  
>
>За пределами класса, в котором определены статические методы и переменные, ими можно пользоваться независимо от любого объекта. Для этого достаточно
 указать имя их класса через *операцию-точку* непосредственно перед их именами. Так, если требуется вызвать статический метод за пределами его класса, это можно сделать, используя следующую общую форму:  
>
>```Java
> имя_класса.метод()
>```
>
>Здесь имя_класса обозначает имя того класса, в котором объявлен статический метод. Как видите, эта форма аналогична той, что применяется для вызова
 нестатических методов через переменные ссылки на объекты. Аналогично для доступа к статической переменной ее имя следует предварить именем ее класса через
 *операцию-точку*. Именно так в Java реализованы управляемые версии глобальных методов и переменных.
>
>Обратимся к конкретному примеру. В теле метода main() обращение к статическому методу callme() и статической переменной "Ь" осуществляется по имени их класса "UseStatic09":  
>[Chapter07/UseStaticByName09 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/UseStaticByName09.java "Посмотреть пример Java")  
></details>

><details><summary>Массивы</summary>
>
>Имея представление о классах, можно сделать следующий важный вывод относительно Массивов: *все они реализованы как объекты*.  
>В частности, размер массива, т.е. количество элементов, которые может содержать массив, хранится в его переменной экземпляра
 *length*. Все массивы обладают этой переменной как свойством, которое всегда содержит размер массива.
>  
>В качестве примера ниже приведена усовершенствованная версия класса Stack. Напомним, что в предшествующих версиях этого класса всегда создавался 10-элементный стек.
 *А новая версия класса Stack позволяет создавать стеки любого размера*.
>  
>Значение свойства stck.length используется с целью предотвратить переполнение стека!!!  
>[Chapter07/StackTest10 - Усовершенствованный класс Stack, в котором используется свойство длины массива](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/StackTest10.java "Посмотреть пример Java")  
></details>

><details><summary>Вложенные и внутренние классы</summary>
>
>Существуют два типа вложенных классов: *Статические и Нестатические.*
 Статическим называется такой вложенный класс, который объявляется с модификатором доступа static. А поскольку он является статическим, то должен обращаться к нестатическим членам своего внешнего класса посредством объекта. Это
 означает, что вложенный статический класс не может непосредственно ссылаться на нестатические члены своего внешнего класса. В силу этого ограничения статические вложенные классы применяются редко.
 Наиболее важным типом вложенного класса является *Внутренний класс.*  
 *Внутренний класс* - это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам своего внешнего класса и может непосредственно ссылаться на них таким же образом, как и остальные нестатические члены внешнего класса.   
>[Chapter07/InnerClassDemo11 - Продемонстрировать применение внутреннего класса](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/InnerClassDemo11.java "Посмотреть пример Java")  
>
>Внутренний класс имеет доступ ко всем элементам своего внешнего класса, но не наоборот.
 Члены внутреннего класса доступны только в области действия внутреннего класса и не могут быть
 использованы внешним классом. Как показано в приведенном ниже примере программы, переменная у
 объявлена как переменная экземпляра класса Inner. Поэтому она недоступна за пределами этого класса
 и не может использоваться в методе showy().  
>[Chapter07/InnerClassDemo12 - Эта программа не подлежит компиляции !!!](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/InnerClassDemo12.java "Посмотреть пример Java")  
>
>Внутренние классы можно определять и в области видимости любого блока кода.
 Например, вложенный класс можно определить в блоке кода, относящегося к методу, или даже в теле цикла for.  
>[Chapter07/InnerClassDemo13 - В этой версии класса Вох один объект допускается инициализировать другим объектом](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/InnerClassDemo13.java "Посмотреть пример Java")  
></details>

><details><summary>Краткий обзор класса String</summary>
>
>Во-первых, следует уяснить, что любая создаваемая символьная строка на самом деле является объектом класса *String*. И даже строковые константы в действительности являются объектами класса *String*.
>  
>Во-вторых, объекты класса *String* являются неизменяемыми. Как только такой объект будет создан, его содержимое не подлежит изменению. На первый
 взгляд это может показаться серьезным ограничением, но на самом деле это не так по следующим причинам:  
>* Если требуется изменить символьную строку, то всегда можно создать новую символьную строку, содержащую все требующиеся изменения.
>* В языке Java определены классы *StringBuffer и StringBuilder*, равноправные классу *String* и допускающие изменение символьных строк, что позволяет выполнять в Java все обычные операции с символьными строками.  
>
>В классе *String* содержится ряд методов, которыми можно пользоваться, программируя на Java. 
 Так, с помощью метода *equals()* можно проверить две символьные строки на равенство, а метод *length()* позволяет выяснить длину символьной строки.   
 Вызывая метод *charAt()*, можно получить символ по заданному индексу. Ниже приведены общие формы этих трех методов.  
>```Java
> boolean еquаls(вторая_строка)
> int length ()
> char сhаrАt(индекс)
>```   
>[Chapter07/StringDemo14 - Продемонстрировать некоторые методы из класса String](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/StringDemo14.java "Посмотреть пример Java")  
>
>Подобно массивам объектов любого другого типа, могут существовать и массивы символьных строк.  
>[Chapter07/StringDemo15 - Продемонстрировать применение массивов объектов типа String](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/StringDemo15.java "Посмотреть пример Java")  
></details>

><details><summary>Аргументы переменной длины</summary>
>
>Метод, который принимает переменное количество арrументов, называется *методом с аргументами переменной длины*.  
>До версии J2SE 5 обработка арrументов переменной длины моrла выполняться двумя способами, ни один из которых не был особенно удобным.
>  
>Во-первых, если максимальное количество аргументов было небольшим и известным, можно было
 создавать перегружаемые варианты метода - по одному для каждого из возможных способов вызова метода. И хотя такой способ вполне работоспособен, он пригоден только в редких случаях.  
 Во-вторых, когда максимальное количество возможных аргументов было большим или неизвестным, применялся подход, при котором аргументы сначала размещались в массиве, а затем массив передавался методу.  
>Такой подход демонстрируется в следующем примере программы:  
>[Chapter07/UseArrayToPassVariableToMethod16 - Использовать массив для передачи методу переменной количество аргументов.](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/UseArrayToPassVariableToMethod16.java "Посмотреть пример Java")  
>
>В данной программе аргументы передаются методу vaTest() через массив v.
 Этот старый подход к обработке аргументов переменной длины позволяет методу vaTest() принимать любое количество аргументов. Но он требует, чтобы эти аргументы были вручную размещены в массиве до вызова метода vaTest(). Создание
 массива при каждом вызове метода vaTest() - задача не только трудоемкая, но и чреватая ошибками. Методы с аргументами переменной длины обеспечивают более простой и эффективный подход к обработке таких аргументов.  
>Для указания аргументов переменной длины служат три точки ( ••• ). В приведенном ниже примере показано, каким образом метод vaTest () можно объявить
 с аргументами переменной длины.  
>```Java
>static void vaтest(int ... v)
>``` 
>В этой синтаксической конструкции компилятору предписывается, что метод vaTest() может вызываться без аргументов или с несколькими аргументами.
 В итоге массив v неявно объявляется как массив типа int[]. Таким образом, в теле метода vaTest() доступ к массиву v осуществляется с помощью синтаксиса обычного массива.
>  
>ВАЖНО!!!
>Во-первых, как отмечалось ранее, в теле метода vaTest() переменная v действует как массив,
 поскольку она действительно является массивом. Синтаксическая конструкция ...
 просто указывает компилятору, что в данном методе предполагается использовать
 переменное количество аргументов и что эти аргументы будут храниться в массиве, на который ссылается переменная v.  
 Во-вторых, метод vaTest() вызывается в методе main() с разным количеством аргументов, в том числе и совсем без них.
 Аргументы автоматически размещаются в массиве и передаются переменной v.
 Если же аргументы отсутствуют, длина этого массива равна нулю.  
>[Chapter07/VarArgs17 - Продемонстрировать применение аргументов переменной длины](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/VarArgs17.java "Посмотреть пример Java")  
>
>Наряду с параметром переменной длины у метода могут быть и "обычные" параметры. Но параметр переменной длины должен быть последним среди всех параметров, объявляемых в методе.  
>```Java
>int doit(int а, int Ь, douЬle с, int ... vals) { }
>```
>Существует еще одно ограничение, о котором следует знать: 
>*метод должен содержать только один параметр с переменным количеством аргументов.*   
>Далее приведена измененная версия метода vaTest(), который принимает как обычный аргумент, так и аргументы переменной длины.  
>[Chapter07/VarArgs18 - Продемонстрировать применение аргументов переменной длины](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/VarArgs18.java "Посмотреть пример Java")  
></details>

><details><summary>Перегрузка методов с аргументами переменной длины</summary>
>
>Метод, принимающий аргументы переменной длины, можно перегружать.  
Есть два возможных способа перегрузки метода с аргументами переменной длины.
>*Первый способ* состоит в том, что у параметра данного метода с переменным количеством аргументов могут быть разные типы. Именно это имеет место в вариантах метода
vaRest ( int ... ) и vaTest (boolean ... ). Напомним, что языковая конструкция . . . вынуждает компилятор обрабатывать параметр как массив заданного
типа. Поэтому, используя разные типы аргументов переменной длины, можно выполнять перегрузку методов с переменным количеством аргументов таким же образом, как и обычных методов с массивом разнотипных параметров. В этом случае исполняющая система Java использует отличие в типах аргументов для выбора
нужного варианта перегружаемого метода.
>
>*Второй способ* перегрузки метода с аргументами переменной длины состоит в том, чтобы добавить один или несколько обычных параметров. Именно это
и было сделано при объявлении метода vaTest (String, int ... ). В данном случае для выбора нужного варианта метода исполняющая система Java использует не только количество аргументов, но и их тип.  
>[Chapter07/VarArgs19 - Аргументы переменной длины и перегрузка](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/VarArgs19.java "Посмотреть пример Java")  
>
>ВАЖНО!!!  
>Метод, поддерживающий переменное количество аргументов, может быть также перегружен методом, который не поддерживает такую возможность. 
 Так, в приведенном выше примере программы метод **vaтest()** может быть перегружен методом **vaтest(int х)**.
 Этот специализированный вариант вызывается только при наличии аргумента типа **int**.
 Если же передаются два или более аргумента типа int, то будет выбран вариант метода **vaтest (int ... v)** с аргументами переменной длины.
></details>

><details><summary>Аргументы переменной длины и неоднозначность</summary>
>
>При перегрузке метода, принимающего аргументы переменной длины, могут происходить непредвиденные ошибки. Они связаны с неоднозначностью, которая
 может возникать при вызове перегружаемого метода с аргументами переменной длины.  
 Параметр с переменным количеством аргументов может быть пустым, поэтому этот вызов может быть преобразован в вызов метода **vaTest (int ... )**
 или **vaTest (boolean ... )**. А поскольку вполне допустимы оба варианта, то данный вызов принципиально неоднозначен.  
[Chapter07/VarArgs20 - Аргументы переменной длины, перегрузка и Неоднозначность](https://github.com/aykononov/JavaSchildt/tree/master/Chapter07/VarArgs20.java "Посмотреть пример Java")  
> Приведенные ниже перегружаемые варианты метода **vaTest()** изначально неоднозначны, несмотря на то, что один из них принимает обычный параметр.  
>```Java
>    static void vaTest (int ... v) { // ...
>    static void vaTest (int n, int ... v) { // ... 
>```
>Несмотря на то что оба списка параметров метода vaTest () отличаются, компилятор не в состоянии разрешить следующий вызов:
>```Java
>vaTest(1)
>``` 
>Из-за ошибок неоднозначности, подобных описанным выше, иногда приходится отказываться от перегрузки и просто использовать один и тот же метод под двумя разными именами. Кроме того, ошибки неоднозначности порой служат признаком принципиальных изъянов в программе, которые можно устранить, тщательно проработав решения поставленной задачи.  
>
></details>

</details>

<details><summary>ГЛАВА 8. "Наследование"</summary>

><details><summary>Основы наследования</summary>
>
>>Как только суперкласс, который определяет общие свойства объекта, будет создан, он может наследоваться для разработки специализированных классов. Каждый подкласс добавляет собственные особые характеристики. В этом и состоит вся суть наследования.
>>
>>[Chapter08/SimpleInheritance01 - Простой пример наследования](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/SimpleInheritance01.java "Посмотреть пример Java")
>
></details>

><details><summary>Практический пример наследования</summary>
>
>>Если ссылочной переменной из Суперкласса присваивается ссылка на объект Подкласса, то доступ предоставляется только к указанным в ней частям объекта, определяемого в Суперклассе, потому-что Суперклассу неизвестно, что именно добавляет в него Подкласс.
>>
>>[Chapter08/DemoBoxWeight02 - Пример, где наследование применяется для расширения класса](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/DemoBoxWeight02.java "Посмотреть пример Java")
>
></details>

><details><summary>Вызов конструкторов Суперкласса с помощью ключевого слова super</summary>
>
>>При вызове метода super() из Подкласса вызывается конструктор его непосредственного Суперкласса. Таким образом, метод super() всегда обращается к Суперклассу, находящемуся в иерархии непосредственно над вызывающим классом. Это справедливо даже для многоуровневой иерархии. Кроме того, вызов метода super() должен быть непременно сделан в первом операторе, выполняемом в теле конструктора Подкласса.
>>
>>[Chapter08/DemoBoxWeight03 - Вызов конструкторов Суперкласса с помощью ключевого слова super](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/DemoBoxWeight03.java "Посмотреть пример Java")
>
></details>

><details><summary>Посмотрим на ссылочные переменные...</summary>
>
>>Можно посмотреть и сравнить, как выглядят ссылочные переменные при клонировании объектов и копировании ссылок на объекты.
>>
>>[Chapter08/ReferenceVariables04 ](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/ReferenceVariables04.java "Посмотреть пример Java")
>
></details>

><details><summary>Создание многоуровневой иерархии</summary>
>
>>Каждый Подкласс наследует все характеристики всех его Суперклассов. Подкласс BoxWeight служит в качестве Суперкласса для создания Подкласса BoxShipment и добавляет к ним поле cost. Благодаря наследованию в классе BoxShipment можно использовать ранее определенные классы Вох и BoxWeight, добавляя только те дополнительные данные, которые требуются для его собственного специализированного применения. В этом и состоит одна из самых ценных особенностей наследования. Она позволяет использовать код повторно. Приведенный пример демонстрирует еще одну важную особенность наследования: метод super() всегда ссылается на конструктор ближайшего по иерархии Суперкласса. В методе super() из класса BoxSlipment вызывается конструктор класса BoxWeight. А в методе super() из класса BoxWeight вызывается конструктор класса Вох. Если в иерархии классов требуется передать параметры конструктору Cуперкласса, то все подклассы должны передавать эти параметры вверх по иерархии. Данное утверждение справедливо независимо от того, нуждается ли Подкласс в собственных параметрах.
>>
>>[Chapter08/DemoShipment05 - Пример, создания многоуровневой иерархии](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/DemoShipment05.java "Посмотреть пример Java")
>
></details>

><details><summary>Порядок вызова конструкторов</summary>
>
>>В иерархии классов конструкторы вызываются в порядке наследования, начиная с суперкласса и кончая подклассом. Более того, этот порядок остается неизменным независимо от того, используется форма super() или нет, поскольку вызов метода super() должен быть в первом операторе, выполняемом в конструкторе подкласса. Если метод super() не вызывается, то используется конструктор по умолчанию или же конструктор без параметров из каждого суперкласса.
>>
>>[Chapter08/CallingConstr06 - Порядок вызова конструкторов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/CallingConstr06.java "Посмотреть пример Java")
>
></details>

><details><summary>Переопределение методов</summary>
>
>>Если в иерархии классов совпадают имена и сигнатуры типов методов из Подкласса и Суперкласса, то говорят, что метод из Подкласса переопределяет метод из Суперкласса. Когда переопределенный метод вызывается из своего Подкласса, он всегда ссылается на свой вариант, определенный в Подклассе. А вариант метода, определенный в Суперклассе, будет скрыт.
>>
>>[Chapter08/OverrideMethod07 - Пример, переопределения методов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/OverrideMethod07.java "Посмотреть пример Java")
>
></details>

><details><summary>Перегрузка методов</summary>
>
>>Переопределение методов выполняется только в том случае, если имена и сигнатуры типов обоих методов одинаковы. В противном случае оба метода считаются перегружаемыми.
>>
>>[Chapter08/OverloadMethod08 - Пример, перегрузки методов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/OverloadMethod08.java "Посмотреть пример Java")
>
></details>

><details><summary>Динамическая диспетчеризация методов</summary>
>
>>Динамическая диспетчеризация методов - это механизм, с помощью которого вызов переопределенного метода разрешается во время выполнения, а не компиляции.
>>Ссылочная переменная из Суперкласса может ссылаться на объект Подкласса. Когда переопределенный метод вызывается по ссылке на Суперкласс, нужный вариант этого метода выбирается в Java в зависимости от типа объекта, на который делается ссылка в момент вызова.
>>
>>В этом примере создаются один Суперкласс А и два его Подкласса В и С. В Подклассах В и С переопределяется метод callme(), объявляемый в классе А. В методе main() объявляются объекты классов А, В и С, а также переменная ref ссылки на объект типа А. Затем переменной ref присваивается по очереди ссылка на объект каждого из классов А, В и С, и по этой ссылке вызывается метод callme().
>>Как следует из результата, выводимого этой программой, выполняемый вариант метода callme() определяется исходя из типа объекта, на который делается ссылка в момент вызова. Если бы выбор делался по типу ссылочной переменной ref, то выводимый результат отражал бы три вызова одного и того же метода callme() из класса А.
>>
>>[Chapter08/DynamicMethodDispatching09 - Динамическая диспетчеризация методов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/DynamicMethodDispatching09.java "Посмотреть пример Java")
>
></details>

><details><summary>Назначение и Применение переопределенных методов</summary>
>
>>Переопределенные методы позволяют поддерживать в Java полиморфизм во время выполнения. Это позволяет определить в общем классе методы, которые станут общими для всех производных от него классов, а в подклассах - конкретные реализации некоторых или всех этих методов.
>>
>>Переопределенные методы предоставляют еще один способ реализовать в Java принцип полиморфизма "один интерфейс, множество методов".
>>
>>Одним из основных условий успешного применения полиморфизма является ясное понимание, что суперклассы и подклассы образуют иерархию по степени увеличения специализации. Если суперкласс применяется правильно, он предоставляет все элементы, к<?торые могут непосредственно использоваться в подклассе. В нем также определяются те методы, которые должны быть реализованы в самом производном классе. Это дает удобную возможность определять в подклассе его собственные методы, сохраняя единообразие интерфейса. Таким образом, сочетая наследование с переопределенными методами, в суперклассе можно определить общую форму для методов, которые будут использоваться во всех его подклассах.
>>
>>Динамический полиморфизм, реализуемый во время выполнения, это один из самых эффективных механизмов объектно-ориентированной архитектуры, обеспечивающих повторное использование и надежность кода. Возможность вызывать из библиотек уже существующего кода методы для экземпляров новых классов, не прибегая к повторной компиляции и в то же время сохраняя ясность абстрактного интерфейса, является сильнодействующим средством.
>>
>>Практический пример, в котором применяется переопределение методов. В приведенной ниже программе создается суперкласс Figure для хранения размеров двумерного объекта, а также определяется метод area() для расчета площади этого объекта. Кроме того, в этой программе создаются два класса,
>>Rectangle и Triangle, производные от класса Figure. Метод area() переопределяется в каждом из этих подклассов, чтобы возвращать площадь четырехугольника и треугольника соответственно.
>>   
>>[Chapter08/FigureFindArea10 - Применение динамического полиморфизма](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/FigureFindArea10.java "Посмотреть пример Java")
>
></details>

><details><summary>Применение абстрактных классов</summary>
>
>>Чтобы убедиться, что в подклассе действительно переопределяются все необходимые методы, достаточно в суперклассе объявить их с модификатором доступа abstract. В суперклассе для них никакой реализации не предусмотрено. Следовательно, эти методы должны быть переопределены в подклассе, где нельзя просто воспользоваться их вариантом, определенным в суперклассе.
>>
>>Любой класс, содержащий один или несколько абстрактных методов, должен  быть также объявлен как абстрактный. У абстрактного класса не может быть никаких объектов. Это означает, что экземпляр абстрактного класса не может быть получен непосредственно с помощью операции new.
>>Любой подкласс, производный от абстрактного класса, должен реализовать все абстрактные методы из своего суперкласса или же сам быть объявлен абстрактным.
>>
>>Кроме того, нельзя объявлять абстрактные конструкторы или абстрактные статические методы.
>>   
>>[Chapter08/AbstractDemo11 - Применение абстрактных методов и классов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter08/AbstractDemo11.java "Посмотреть пример Java")
>
></details>

><details><summary>Предотвращение переопределения с помощью ключевого слова final</summary>
>
>>Методы, объявленные как f inal, переопределяться не могут. Это способствует увеличению производительности программы, поскольку Компилятор вправе встраивать вызовы этих методов, так как ему известно, что они не будут переопределены в подклассе.  
>>
>>```java
>>class A {
>>    final void meth() {
>>        System.out.println("Этo конечный метод.");
>>    }   
>>}
>>class B extends A {
>>    void meth() {
>>        // ОШИБКА!!! Этот метод не может быть переопределен.
>>    }
>>}
>>```
></details>

><details><summary>Предотвращение наследования с помощью ключевого слова final</summary>
>
>>Иногда требуется предотвратить наследование класса. Для этого в начале объявления класса следует указать ключевое слово f inal. Объявление класса конечным неявно делает конечными и все его методы. Нетрудно догадаться, что одновременное объявление класса как abstract и final недопустимо, поскольку абстрактный класс принципиально является незавершенным, и только его подклассы предоставляют полную реализацию методов. Ниже приведен пример конечного класса.
>>Как следует из комментария к приведенному выше коду, класс В не может наследовать от класса А, поскольку класс А объявлен конечным.
>>
>>```java
>>final class A {
>>    // ...
>>}
>>// Следующий класс недопустим!!!
>>class B extends A {
>>   // ОШИБКА!!! Класс А не может иметь подклассы.
>>}
>>```
></details>

><details><summary>Класс Object</summary>
>
>>В языке Java определен один специальный класс, называемый Obj ect. Все остальные классы являются подклассами, производными от этого класса. Это означает, что класс Obj ect служит суперклассом для всех остальных классов, и ссылочная переменная из класса Obj ect может ссылаться на объект любого другого класса. А поскольку массивы реализованы в виде классов, то ссылочная переменная типа Obj ect может ссылаться и на любой массив. В классе Obj ect определены методы, перечисленные ниже:
>>
>>|Метод |Назначение |
>>|:-----------------------------|:-------------------------------------|
>>|Object clone() |Создает новый объект, не отличающийся от клонируемго |
>>|boolean equals(Object object) | Определяет, равен ли один объект другому |
>>|void finalize() |Вызывается перед удалением неиспользуемого объекта (не рекомендован для применения, начиная с версии JDK 9) |
>>|Class<?> getClass() |Получает класс объекта во время выполнения |
>>|int hashCode() |Возвращает хеш-код, связанный с вызывающим объектом |
>>|void notify() |Возобновляет исполнение потока, ожидающего вызывающего объекта |
>>|void notifyAll() |Возобновляет исполнение всех потоков, ожидающих вызывающий объект |
>>|String toString() |Возвращает символьную строку, описывающую объект |
>>|void wait() |Ожидает другого потока исполнения |
>>|void wait(long миллисекунд) |Ожидает другого потока исполнения |
>>
>>Методы getClass(), notify(), notifyAll() и wait() объявлены как final. Остальные методы можно переопределять (они будут описаны в последующих главах данной книги). Обратите, однако, внимание на два метода: equals() и toString(). Метод equals() сравнивает два объекта. Если объекты равны, он возвращает логическое значение true, а иначе - логическое значение false.
>>Точное определение равенства зависит от типа сравниваемых объектов. Метод toString() возвращает символьную строку с описанием объекта, для которого он вызван. Кроме того, метод toString() вызывается автоматически, когда содержимое объекта выводится с помощью метода println(). Этот метод переопределяется во многих классах, чтобы приспосабливать описание к создаваемым в них конкретным типам объектов.
>
></details>

</details>

<details><summary>ГЛАВА 9. "Пакеты и интерфейсы"</summary>

**Очень важно освоить пакеты и интерфейсы настолько, чтобы свободно пользоваться этими языковыми средствами, программируя на Java.**  
 
><details><summary>Определение пакета</summary>
>
>>Пакеты являются контейнерами классов и служат для разделения пространств имен классов.  
>>Классы и пакеты одновременно служат для инкапсуляции и обозначения пространства имен и области видимости переменных и методов. Пакеты служат в качестве контейнеров для классов и других подчиненных пакетов, а классы - для данных и кода. Класс - наименьшая единица абстракции в Java. Характер взаимодействия пакетов и классов в Java определяет четыре категории доступности членов классов.  
>>* Подклассы из одного пакета.
>>* Классы из одного пакета, не являющиеся подклассами.
>>* Подклассы из разных пакетов.
>>* Классы, не относящиеся к одному пакету и не являющиеся подклассами.
>>  
>>Три модификатора доступа (private, рublic и protected) обеспечивают  различные способы создания многих уровней доступа, необходимых для этих категорий.  
Любой компонент, объявленный как (рublic), доступен из любого кода. А любой компонент, объявленный как (private), недоступен для компонентов, находящихся за пределами его класса. 
Если в объявлении члена класса отсутствует явно указанный модификатор доступа, этот член доступен для подклассов и других классов из данного пакета. Такой уровень доступа используется по умолчанию.
Если же требуется, чтобы компонент был доступен за пределами его текущего пакета, но только классам, непосредственно производным от данного класса, такой компонент должен быть объявлен как (protected).  
Для класса, не являющегося вложенным, может быть указан только один из двух возможных уровней доступа: по умолчанию и открытый (рublic). Если класс объявлен как (рublic), он доступен из любого другого кода. 
Если у класса имеется уровень доступа по умолчанию, такой класс оказывается доступным только для кода из данного пакета. Если же класс оказывается открытым, он должен быть единственным открытым классом, объявленным в файле, а имя этого файла должно
совпадать с именем класса. 
>
></details>

><details><summary>Пример доступа к пакетам</summary>
>
>>[Chapter09/pkg01/MainDemo - получить экземпляры различных классов из пакета pkg01](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/pkg01/MainDemo.java "Посмотреть пример Java")  
>>[Chapter09/pkg01/MainDemo - получить экземпляры различных классов из пакета pkg02](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/pkg02/MainDemo.java "Посмотреть пример Java")  
>
></details>

><details><summary>Импорт пакетов</summary>
>
>>Все классы из стандартной библиотеки Java хранятся в пакете **java**. Основные
  языковые средства хранятся в пакете **java.lang**, входящем в пакет **java**.
  Обычно каждый пакет или класс, который требуется использовать, приходится
  импортировать. Но, поскольку программировать на Java бесполезно без многих
  средств, определенных в пакете **java.lang**, компилятор неявно импортирует его
  для всех программ. Это равнозначно наличию следующей строки кода в каждой из
  программ на Java:
>>```Java
>>import java.lang.*;
>>```
>>Компилятор никак не отреагирует на наличие классов с одинаковыми именами в двух разных пакетах, импортируемых в форме со звездочкой, если только не
  будет предпринята попытка воспользоваться одним из этих классов. В таком случае возникнет ошибка во время компиляции, и тогда имя класса придется указать явно вместе с его пакетом.  
  Следует особо подчеркнуть, что указывать оператор **import** совсем не обязательно. *Полностью уточненное имя* класса с указанием всей иерархии пакетов
  можно использовать везде, где допускается имя класса. Например, в приведенном ниже фрагменте кода применяется оператор **import**.  
>>```Java
>>import java.util.*;
>>class MyDate extends Date { ... }
>>```  
>>Этот же фрагмент кода, но без оператора **import**, где класс **Date** определен с помощью полностью уточненного его имени.  
>>```Java
>>class MyDate extends java.util.Date { ... }
>>```  
>>При импорте пакета классам, не производным от классов из данного пакета в импортирующем коде, будут доступны только те элементы
  пакета, которые объявлены как **рublic**. Так, если требуется, чтобы упоминавшийся ранее класс **Balance** из пакета **mypack** был доступен в качестве самостоятельного класса за пределами пакета **mypack**, его следует объявить как **public** и разместить в отдельном файле:  
>>[Chapter09/mypack/Balance - Пример самостоятельного класса за пределами пакета mypack](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/mypack/Balance.java "Посмотреть пример Java")
>>
>>Класс Balance объявлен как **рublic**. Его конструктор и метод **show()** также объявлены как **public**. Это означает, что они доступны для любого кода за пределами пакета **mypack**.   
  Например, класс **TestBalance** импортирует пакет **mypack**, и поэтому в нем может быть использован класс **Ваlancе**:  
>>[Chapter09/mypack02/TestBalance - Пример пример, класс TestBalance импортирует пакет mypack](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/mypack02/TestBalance.java "Посмотреть пример Java")
></details>

><details><summary>Интерфейсы</summary>
>
>В версии JDK 8 ключевое слово **interface** дополнено средством, значительно изменяющим его возможности. До версии JDK 8 в интерфейсе вообще нельзя было ничего реализовать.  
>С версии JDK 8, метод можно объявлять в интерфейсе с *реализачией по умолчанию*, т.е. указать его поведение. В *традиционной* форме интерфейсы можно попрежнему создавать и использовать и без методов с реализацией по умолчанию.
> 
>*Интерфейсы* аналогичны классам, но они не содержат переменные экземпляра и объявления их методов, как правило, не содержат тело метода.  
>Как только *интерфейс* определен, его может реализовать любое количество классов. А один класс может реализовать любое количество интерфейсов.
>Чтобы реализовать *интерфейс*, в классе должен быть создан полный набор методов, определенных в этом интерфейсе и в каждом классе могут быть определены особенности собственной реализации этого интерфейса.
>Ключевое слово **intеrfасе** позволяет в полной мере использовать принцип полиморфизма **"один интерфейс, несколько методов"**.  
>Если *интерфейс* объявлен как **public**, он может быть использован в любом другом коде. В этом случае интерфейс должен быть *единственным открытым интерфейсом*, объявленным в файле, а *имя этого файла должно совпадать с именем интерфейса*.  
>Каждый класс, который включает в себя интерфейс, должен реализовать все его методы. В объявлениях интерфейсов могут быть объявлены *переменные*. Они неявно объявляются как *final и stаtiс*, т.е. их нельзя изменить в классе, реализующем интерфейс. Кроме того, они должны быть *инициализированы*. Все методы и переменные неявно объявляются в интерфейсе как **рubliс**.
>```Java
>interface Callback {
>    void callback(int param);
>}
>```
></details>

><details><summary>Реализация интерфейсов</summary>
>
>Как только интерфейс определен, он может быть реализован в одном или нескольких классах. Чтобы реализовать интерфейс, в определение класса требуется
 включить выражение **implements**, а затем создать методы, определенные в интерфейсе.
>
>Если в классе реализуется больше одного интерфейса, имена интерфейсов разделяются запятыми. Так, если в классе реализуются два интерфейса, в которых
 объявляется один и тот же метод, то этот же метод будет использоваться клиентами любого из двух интерфейсов. Методы, реализующие элементы интерфейса,
 должны быть объявлены как **public**. Кроме того, сигнатура типа реализующего метода должна в точности совпадать с сигнатурой типа, указанной в определении **interface**.
>
>[Chapter09/Interfaces/Callback - Пример, где объявляется простой интерфейс Callback](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Interfaces/Callback.java "Посмотреть пример Java")  
>**ВАЖНО!!!** Если метод реализуется из интерфейса, он должен быть объявлен как **рublic**.  
>[Chapter09/Interfaces/Client - Пример, где реализуется приведенный ранее интерфейс Callback](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Interfaces/Client.java "Посмотреть пример Java")  
>
>
></details>

><details><summary>Доступ к реализациям через ссылки на интерфейсы</summary>
>
>*Переменные* можно объявлять как ссылки на объекты, в которых используется тип *интерфейса*, а не тип класса. Таким образом переменной можно ссылаться на любой экземпляр любого класса, реализующего объявленный интерфейс.
>Одна из главных особенностей интерфейсов - при вызове метода по одной из таких ссылок нужный вариант будет выбираться в зависимости от конкретного экземпляра интерфейса, на который делается ссылка. Поиск исполняемого метода осуществляется динамически во время выполнения, что позволяет создавать классы позднее, чем код, из которого вызываются методы этих классов. 
 Вызывающий код может выполнять диспетчеризацию методов с помощью интерфейса, даже не имея никаких сведений о вызываемом коде.
>
>Обратите внимание: переменной "с" присвоен экземпляр класса Client, несмотря на то, что она объявлена с типом интерфейса Callback. Переменную с можно использовать для доступа 
 к методу callback(), она не предоставляет доступа к каким-нибудь другим членам класса Client. Переменная ссылки на интерфейс располагает только сведениями о методах, объявленных в том интерфейсе, на который она ссылается. Таким образом, переменной с нельзя пользоваться
 для доступа к методу nonI faceMeth(),поскольку этот метод объявлен в классе Client, а не в интерфейсе Callback. 
>[Chapter09/Interfaces/TestIface - Пример программы, где метод callback() вызывается через переменную ссылки на интерфейс Callback](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Interfaces/TestIface.java "Посмотреть пример Java")  
>
>Чтобы продемонстрировать *полиморфные* возможности, создадим вторую реализацию интерфейса Callback.
>[Chapter09/Interfaces/Client2 - Вторая реализация интерфейса Callback](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Interfaces/Client2.java "Посмотреть пример Java")  
>Вызываемый вариант метода callback() выбирается в зависимости от типа объекта, на который переменная "с" ссылается во время выполнения.  
>[Chapter09/Interfaces/TestIface2 - Пример программы демонстрирует полиморфные возможности](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Interfaces/TestIface2.java "Посмотреть пример Java")  
></details>

><details><summary>Частичные реализации</summary>
>
>Если класс включает в себя интерфейс, но не полностью реализует определенные в нем методы, он должен быть объявлен как **abstract**.  
>В данном примере кода класс Incomplete не реализует метод callback(), поэтому он должен быть объявлен как *абстрактный*. Любой класс, наследующий от класса Incomplete, должен реализовать метод callback() или быть также объявленным как **abstract**.  
>```Java
>abstract class Incomplete implements Callback {
>    int a, b;
>
>    void show() {
>        System.out.println(a + " " + b);
>    }
>    // ...
>}
>```
>
></details>

><details><summary>Вложенные интерфейсы</summary>
>
>Интерфейс может быть объявлен членом класса или другого интерфейса. Такой интерфейс называется интерфейсом-членом или *вложенным интерфейсом*. Вложенный 
 интерфейс может быть объявлен как *рublic, private или protected*. Этим он отличается от интерфейса верхнего уровня, который должен быть объявлен как *publiс* 
 или использовать уровень доступа *по умолчанию*. Когда *вложенный интерфейс* используется за пределами объемлющей его области действия, *его имя должно быть дополнительно уточнено именем класса или интерфейса*, членом которого он является. Это означает, что за пределами класса или интерфейса, в котором объявлен вложенный интерфейс, его имя должно быть уточнено полностью.
>  
>Обращаем внимание на то, что в классе А определяется вложенный интерфейс NestedIF, объявленный как рublic. Затем вложенный интерфейс реализуется в классе В следующим образом:  
>```Java
>implements A.NestedIF
>```  
>[Chapter09/NestedInterfaces/NestedIFDemo - Пример вложенного интерфейса](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/NestedInterfaces/NestedIFDemo.java "Посмотреть пример Java")
></details>

><details><summary>Применение интерфейсов</summary>
>
>В предыдущих Главе 6 был разработан класс Stack, реализующий простой стек фиксированного размера. Однако стек можно реализовать разными способами, но независимо от реализации стека,
 его интерфейс остается неизменным. Это означает, что методы push() и рор() определяют интерфейс стека независимо от особенностей его реализации. А поскольку интерфейс стека отделен от его реализации, то такой интерфейс можно определить без особого труда, оставив уточнение конкретных деталей в его реализации.  
>[Chapter06/Stack - класс Stack фиксированного размера](https://github.com/aykononov/JavaSchildt/blob/master/Chapter06/Stack.java "Посмотреть пример Java")
>
>Создадим сначала интерфейс, определяющий целочисленный стек, разместив его в файле IntStack.java. Этот интерфейс будет использоваться в обеих реализациях стека.  
>[Chapter09/Stack/IntStack - Пример интерфейса для целочисленного стека](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Stack/IntStack.java "Посмотреть пример Java")
>
>В приведенной ниже программе создается класс FixedStack, реализующий версию целочисленного стека фиксированной длины.
>[Chapter09/Stack/IFFixedStack - Реализация интерфейса IntStack для стека фиксированного размера](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Stack/IFFixedStack.java "Посмотреть пример Java")
>
>Ниже приведена еще одна реализация интерфейса IntStack, в которой с помощью того же самого определения interface создается динамический стек. В этой реализации каждый стек создается с первоначальной длиной. При превышении этой начальной длины размер стека увеличивается. Каждый раз, когда возникает потребность в дополнительном свободном месте, размер стека удваивается.  
>[Chapter09/Stack/IFDynStack - Реализация "наращиваемого" стека](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Stack/IFDynStack.java "Посмотреть пример Java")
>
>В приведенном ниже примере программы создается класс, в котором используются обе реализации данного интерфейса в классах FixedStack и DynStack.
 Для этого применяется ссылка на интерфейс. Это означает, что поиск вариантов при вызове методов push() и рор() осуществляется во время выполнения, а не во время компиляции.
>
>В этой программе переменная myStack содержит ссылку на интерфейс IntStack. Следовательно, когда она ссылается на переменную dynStack, выбираются варианты методов push() и рор(), определенные при реализации данного интерфейса в классе DynStack.
 Когда же она ссылается на переменную fixedStack, выбираются варианты методов push() и рор(),определенные при реализации данного интерфейса в классе FixedStack. Как отмечалось ранее, все эти решения принимаются во время выполнения.  
>[Chapter09/Stack/IFTestЗ - Создать переменную интерфейса и обратиться к обоим стекам через нее](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/Stack/IFTestЗ.java "Посмотреть пример Java")  
>*Обращение к нескольким реализациям интерфейса через ссылочную переменную интерфейса является наиболее эффективным средством в Java для поддержки полиморфизма во время выполнения*.
></details>

><details><summary>Переменные в интерфейсах</summary>
>
>Интерфейсы можно применять для импорта совместно используемых констант в несколько классов путем простого объявления интерфейса, который содержит
 переменные, инициализированные нужными значениями. Когда интерфейс включается в класс (т.е. реализуется в нем}, имена всех этих переменных оказываются в области действия констант.
>
>Если интерфейс не содержит никаких методов, любой класс, включающий такой интерфейс, на самом деле ничего
 не реализует. Это все равно, как если бы класс импортировал постоянные поля
 в пространство имен класса в качестве конечных переменных. В следующем примере программы эта методика применяется для реализации автоматизированной системы "принятия решений":    
>[Chapter09/VariablesInInterfaces/AskМe - Реализация автоматизированной системы "принятия решений"](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/VariablesInInterfaces/AskМe.java "Посмотреть пример Java")  
>*В рассматриваемом здесь примере программы два класса, Question и AskMe,  реализуют интерфейс SharedConstants, в котором определены константы NO(Нет), YES(Да), МАУВЕ(Возможно), SOON(Вскоре), LATER(Позже) и NEVER(Никогда). Код из каждого класса ссылается на эти константы так, как если бы они определялись и наследовались непосредственно в каждом классе*.
></details>

><details><summary>Расширение интерфейсов</summary>
>
>Ключевое слово ext ends позволяет одному интерфейсу наследовать другой.
 Синтаксис определения такого наследования аналогичен синтаксису наследования классов. Когда класс реализует интерфейс, наследующий другой интерфейс,
 он должен предоставлять реализации всех методов, определенных по цепочке наследования интерфейсов.      
>[Chapter09/ExtendsInterfaces/IFExtend - Пример расширения интерфейсов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/ExtendsInterfaces/IFExtend.java "Посмотреть пример Java")    
></details>

><details><summary>Методы с реализацией по умолчанию</summary>
>
>До версии JDK 8 в интерфейсе нельзя было вообще реализовывать методы. Эти методы были абстрактными и не имели своего тела - *традиционная форма интерфейса*.  
>В версии JDK 8 появилась новая возможность вводить в интерфейс так называемый *метод с реализацией по умолчанию*, разрешает объявлять в интерфейсе метод не с абстрактным, а конкретным телом.  
>**Метод с реализацией по умолчанию дает возможность предоставить средства, позволяющие расширять интерфейсы, не нарушая уже существующий код**.
>   
>Важно отметить, что внедрение методов с реализацией по умолчанию не изменяет главную особенность интерфейсов: неспособность сохранять данные состояния. В частности, в интерфейсе по-прежнему недопустимы переменные экземпляра. Следовательно, интерфейс отличается от класса тем, что он не допускает сохранение состояния. Более того, создавать экземпляр самого интерфейса нельзя.
 Поэтому интерфейс должен быть по-прежнему реализован в классе, если требуется получить его экземпляр, несмотря на возможность определять в интерфейсе
 методы с реализацией по умолчанию, начиная с версии JDK 8.  
>Замечание!!! *Методы с реализацией по умолчанию* служат специальным целям. А *создаваемые интерфейсы* по-прежнему определяют, главным образом, *ЧТО* именно следует сделать, но не *КАК* это сделать.  
>При объявлении *метода с реализацией по умолчанию* указывается ключевое слово default:
>```Java
>interface  MyInterFace {
>    // Это обычный метод
>    int getNumber();
>    
>    // Метод с реализацией по умолчанию - он просто возвращает символьную строку
>    default String getString() {
>        return "Объект типа String по умолчанию";
>    }
>}
>```  
>В связи с тем что в объявление метода getString() включена его *реализация по умолчанию*, его совсем не обязательно переопределять в классе, реализующем интерфейс MyInterFace.  
>[Chapter09/DefaultMethods/DefaultMethMain - Пример использования реализации метода по умолчанию](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/DefaultMethods/DefaultMethMain.java "Посмотреть пример Java")  
>[Chapter09/DefaultMethods/DefaultMethMain2 - В этом классе предоставляются реализации обоих методов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/DefaultMethods/DefaultMethMain2.java "Посмотреть пример Java")  
>
>Усовершенствуем интерфейс IntStack дополнив его новыми функциональными возможностями, не нарушая уже существующий код. 
>Благодаря внедрению методов с реализацией по умолчанию добавим метод очищающий стек, чтобы подготовить его к повторному использованию.  
>Например, интерфейс IntStack можно усовершенствовать следующим образом:  
>```Java
>interface IntStack {
>    void push(int item); // сохранить элемент в стеке
>    int pop(); // извлечь элемент из стека
>    
>    // метод очищающий стек по умолчанию
>    default void clear() {
>    System.out.println("Метод очищающий стек пока не реализован.");
>    }   
>}
>```
>Данный метод пока только выводит сообщение по умолчанию. Его нельзя вызвать из уже существующего класса, реализующего интерфейс IntStack.
>
>Но метод clear() может быть реализован в новом классе вместе с интерфейсом IntStack. Новую реализацию метода clear() потребуется определить лишь в том случае, если он используется.  
>
>*Метод с реализацией по умолчанию* предоставляет возможность сделать следующее:  
>* изящно расширить интерфейс со временем;
>* предоставить дополнительные функциональные возможности, исключая замещающую реализацию в классе, если эти функциональные возможности не требуются.  
>
>*Методы с реализацией по умолчанию* предоставляют отчасти возможности, которые обычно связываются с понятием *множественного наследования*. Например, в одном классе можно реализовать два интерфейса. Если
  в каждом из этих интерфейсов предоставляются методы с реализацией по умолчанию, то некоторое поведение наследуется от обоих интерфейсов.  
>* Приоритет отдается реализации метода в классе над его реализацией в интерфейсе.  
>* В тех случаях, когда один интерфейс наследует другой и в обоих интерфейсах
   определяется общий метод с реализацией по умолчанию, предпочтение отдается
   варианту метода из наследующего интерфейса.  
></details>

><details><summary>Применение статических методов в интерфейсе</summary>
>
>В JDK 8, у интерфейсов появилась еще одна возможность: определять в нем один или несколько *статических методов*.  
>Метод, объявляемый в интерфейсе как static, можно вызывать независимо от любого объекта. И для этого не требуется ни реализация такого метода
 в интерфейсе, ни экземпляр самого интерфейса. Напротив, для вызова статического метода достаточно указать имя интерфейса и через точку имя самого метода.  
>В приведенном ниже примере кода демонстрируется ввод статического метода getDefaultNumber() в упоминавшийся ранее интерфейс MyIF. Этот метод возвращает нулевое значение.  
>```Java
>public interface MyIF {
>     // Это объявление обычного метода в интерфейсе. Он НЕ предоставляет реализацию по умолчанию
>     int getNumber();
> 
>     // А это объявление метода с реализацией по умолчанию. Обратите внимание на его реализацию по умолчанию
>     default String() {
>         return "Объект типа String по умолчанию";
>     }
> 
>     // Это объявление статического метода в интерфейсе
>     static int getDefaultNumber {
>         return 0;
>     }
> }
>```
>Метод getDefaultNumber() может быть вызван следующим образом:
>```Java
> int defNum = MyIF.getDefaultNumber(); 
>```
>Для вызова метода getDefaultNumber() реализация или экземпляр интерфейса MyIF не требуется, поскольку это *статический метод*.  
>Замечание: *статические методы из интерфейсов не наследуются ни реализующими их классами, ни подчиненными интерфейсами.*  
>
>[Chapter09/ExtendsInterfaces/IFExtend - Пример расширения интерфейсов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter09/ExtendsInterfaces/IFExtend.java "Посмотреть пример Java")    
></details>

><details><summary>Закрытые методы интерфейсов</summary>
>
>С версии JDK 9, в интерфейс можно включать *закрытый метод*. Такой метод можно вызвать только из метода, *реализуемого по умолчанию* или другого
 *закрытого метода* в том же самом интерфейсе. А поскольку *закрытый метод* интерфейса объявляется как private, то им нельзя воспользоваться в коде за пределами того интерфейса, где он определен.
>  
>**Главное преимущество закрытого метода** интерфейса заключается в том, что он позволяет использовать общий фрагмент кода в двух и большем числе методов
 с реализацией по умолчанию, исключая тем самым дублирование кода.
>  
>В качестве примера ниже приведена очередная версия интерфейса IntStack с двумя реализуемыми по умолчанию методами popNElements() и skipAndPopNElements().
 Первый из них возвращает массив из N элементов, начиная с вершины стека, а второй сначала пропускает указанное количество элементов, а затем возвращает массив из следующих N элементов. В обоих методах вызывается закрытый метод getElements() с целью извлечь из стека массив с указанным количеством элементов.  
>
>Обратите внимание на то, что закрытый метод getElements() вызывается в обоих методах popNElements() и skipAndPopNElements() с целью получить возвращаемый массив извлекаемых из стека элементов. Благодаря этому исключается дублирование одного и того
 же кода в этих реализуемых по умолчанию методах.
>
>Следует, однако, иметь в виду, что метод getElements() нельзя вызвать за пределами его интерфейса, поскольку он объявлен закрытым. Это означает, что
 его применение ограничивается пределами интерфейса IntStack (в данном случае - методами с реализацией по умолчанию). А поскольку для извлечения элементов из стека в методе getElements() применяется метод рор(), то в нем
 автоматически вызывается вариант данного метода, предоставляемый в реализации интерфейса IntStack. Следовательно, метод пригоден для работы с классом
 любого стека, реализующим интерфейс IntStack.  
>```java
>//Очередная версия интерфейса IntStack с закрытым методом, применяемым в двух реализуемых по умолчанию методах.
> interface IntStack {
>     void push(int item); // сохранить элемент в стеке
>     int pop();           // извлечь элемент из стека
> 
>     // Метод с реализацией по умолчанию, возвращающий массив из N элементов, начиная с вершины стека
>     default int[] popNElements(int n) {
>         return getElements(n); // возвратить запрашиваемые элементы из стека
>     }
> 
>     // Метод с реализацией по умолчанию, возвращающий из стека массив из N элементов,
>     // следующих после указанного количества пропускаемых элементов
>     default int[] skipAndPopNElements(int skip, int n) {
>         getElements(skip);      // пропустить указанное количество элементов в стеке
>         return getElements(n);  // возвратить запрашиваемые элементы из стека
>     }
> 
>     // Закрытый метод, возвращающий массив из N элементов, начиная с вершины стека
>     private int[] getElements(int n) {
>         int[] elements = new int[n];
>         for (int i = 0; i < n; i++) elements[i] = pop();
>         return elements;
>     }
> }
>``` 
>*Как правило, закрытые методы интерфейсов не находят широкого применения.* 
></details>

</details>

<details><summary>ГЛАВА 10. "Обработка исключений"</summary>

><details><summary>Исключение</summary>
>
>**Исключение** - это ошибка, возникающая во время выполнения. Исключение представляет собой объект, описывающий исключительную ситуацию, возникающую в определенной части програмного кода.
Когда возникает такая ситуация, в вызвавшем ошибку методе генерируется объект, который представляет исключение. Этот метод может обработать исключение самостоятельно или же пропустить его. Так или иначе, в определенный
момент исключение перехватывается и обрабатывается. Исключения могут генерироваться автоматически исполняющей системой Java или вручную в прикладном коде. Исключения, генерируемые исполняющей системой Java, имеют
отношение к фундаментальным ошибкам, нарушающим правила языка Java или ограничения, налагаемые исполняющей системой Java. А исключения, генерируемые вручную, обычно служат для уведомления вызывающего кода о некоторых
ошибках в вызываемом методе.
>
>**Общая форма блока обработки исключений:**
>
>```Java
>try {
>    // блок кода, в котором отслеживаются ошибки
>catch (тип_исключения_1 ехOЬ) {
>    // обработчик исключений тип_исключения_1
>catch (тип_исключения_2 ехОЬ) {
>    // обработчик исключений тип_исключения_2
> }
> // ... 
>finally {
> // блок кода, который должен быть непременно
> // выполнен по завершении блока try
>}
>```
></details>

><details><summary>Типы исключений</summary>
>  
>Все типы исключений являются подклассами, производными от встроенного класса **Throwable**. Это означает, что класс **Throwable** находится на вершине
 иерархии классов исключений. Сразу же за классом **Throwable** ниже по иерархии следуют два подкласса, разделяющие все исключения на две ветви. Одну ветвь
 возглавляет класс **Exception**. Он служит для исключительных условий, которые должна перехватывать прикладная программа. *Именно от этого класса вам
 и предстоит наследовать свои подклассы при создании собственных типов исключений*. У класса **Exception** имеется важный подкласс - **RuntimeException**.
 Исключения типа **RuntimeException** автоматически определяются для создаваемых вами прикладных программ и охватывают такие ошибки, как деление на нуль и ошибочная
 индексация массивов.
>
>Другая ветвь возглавляется классом **Error**, определяющим исключения, появление которых не предполагается при нормальном выполнении программы.
 Исключения типа **Error** используются в исполняющей системе Java для обозначения ошибок, происходящих в самой исполняющей среде. Примером такой ошибки
 может служить *переполнение стека*.
>```
>            Throwable
>       -------------------
>      |                   |
>      v                   v
>  Exception             Error
>      |
>      v
>RuntimeException
>```
></details>

><details><summary>Необрабатываемые исключения</summary>
>
>Прежде чем перейти непосредственно к обработке исключений, имеет смысл продемонстрировать, что происходит, когда исключения не обрабатываются.
>Когда исполняющая система Java обнаруживает попытку деления на нуль, она создает новый объект исключения, а затем генерирует исключение. Это прерывает выполнение класса ЕхсО, ведь как только исключение сгенерировано, оно
 должно быть перехвачено обработчиком исключений и немедленно обработано.
>
>В данном примере обработчик исключений отсутствует, и поэтому исключение перехватывается стандартным обработчиком, предоставляемым исполняющей системой Java. Любое исключение, не перехваченное прикладной программой, в конечном итоге будет перехвачено и обработано этим стандартным обработчиком.
 Стандартный обработчик выводит символьную строку с описанием исключения и результат трассировки стека, начиная с момента возникновения исключения, а затем прерывает выполнение программы.
>  
>В приведенный ниже пример небольшой программы намеренно введен оператор, вызывающий ошибку деления на нуль.
>[Chapter10/Exc0 - Пример, когда исключение не обрабатывается](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/Exc0.java "Посмотреть пример Java")
>
></details>

><details><summary>Применение блоков операторов try и catch</summary>
>
>Чтобы организовать *обработку ошибок*, возникающих во время выполнения, достаточно разместить контролируемый  код в блоке оператора *try*. Сразу же за блоком оператора *try* должен следовать блок оператора *catch*, где указывается тип перехватываемого исключения.  
 Как только возникнет исключение, управление сразу же передается из блока оператора *try* в блок оператора *catch*. По завершении блока оператора *catch* управление передается в строку кода, следующую после всего блока операторов *try/catch*.  
>
>Операторы *try* и *catch* составляют единое целое. Область действия блока оператора *catch* не распространяется на операторы, предшествующие блоку оператора *try*. Оператор *catch* не в состоянии перехватить исключение, переданное другим оператором *try*, кроме описываемых далее конструкций вложенных
 операторов *try*. Операторы, защищаемые блоком оператора *try*, должны быть заключены в фигурные скобки (т.е. должны находиться в самом блоке). Оператор *try* нельзя применять к отдельному оператору в исходном коде программы.  
>[Chapter10/Exc2 - Пример обработки исключения](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/Exc2.java "Посмотреть пример Java")
>
>Целью большинства правильно построенных операторов *catch* является разрешение исключительных ситуаций и продолжение нормальной работы программы, как если бы ошибки вообще не было. В приведенном ниже примере программы на каждом
 шаге цикла *for* получаются два случайных числа. Эти два числа делятся одно на другое, а результат используется для деления числового значения *12* . Окончательный результат размещается в переменной а. Если какая-нибудь из этих операций деления
 приводит к ошибке деления на нуль, эта ошибка перехватывается, в переменной а устанавливается нулевое значение и программа выполняется дальше.  
>[Chapter10/HandleError - Обработать исключение и продолжить работу](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/HandleError.java "Посмотреть пример Java")
></details>

><details><summary>Применение нескольких операторов catch</summary>
>
>Когда в одном фрагменте кода возникает более одного исключения. В таком случае можно указать два или больше оператора *catch*, каждый из которых предназначается для перехвата отдельного типа исключения. Когда генерируется исключение, каждый оператор *catch* проверяется по порядку, и выполняется тот из них, который совпадает по типу с возникшим исключением. По завершении одного из операторов *catch* все остальные пропускаются, и выполнение программы продолжается с оператора, следующего сразу за блоком операторов *try/catch*.
>
>В этой программе произойдет исключение в связи с делением на нуль, если она будет запущена без аргументов командной строки. Ведь в этом случае значение переменной а будет равно нулю. Деление будет выполнено нормально, если
 программе будет передан аргумент командной строки, устанавливающий в переменной а значение больше нуля. Но в этом случае возникнет исключение типа
 *ArrayindexOutOfBoundsException*, поскольку длина массива целых чисел "m" равна 1, тогда как программа пытается присвоить значение элементу массива "m" [10].  
>[Chapter10/MultipleCatches - Продемонстрировать применение нескольких операторов catch](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/MultipleCatches.java "Посмотреть пример Java")  
>
>*Важно помнить, что перехват исключений из подклассов должен следовать до перехвата исключений из суперклассов.*  
>
>Дело в том, что оператор *catch*, в котором перехватывается исключение из суперкласса, будет перехватывать все исключения из этого суперкласса, а также все
 исключения из его подклассов. Это означает, что исключения из подкласса вообще не будут обработаны, если попытаться перехватить их после исключений из его суперкласса. Кроме того, недостижимый код считается в Java ошибкой.  
>[Chapter10/SuperSubCatch - Эта программа содержит ошибку](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/SuperSubCatch.java "Посмотреть пример Java")  
>
>Если попытаться скомпилировать эту программу, то появится сообщение об ошибке, уведомляющее, что второй оператор *catch* недостижим, потому что
 исключение уже перехвачено. Класс исключения типа *ArithmeticException* является производным от класса *Exception*, и поэтому первый оператор *catch*
 обработает все ошибки, относящиеся к классу *Exception*, включая и класс *ArithmeticException*. Это означает, что второй оператор catch так и не будет
 выполнен. Чтобы исправить это положение, придется изменить порядок следования операторов *catch*.  
> [Chapter10/SuperSubCatch2 - В этом коде исправлена ошибка](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/SuperSubCatch2.java "Посмотреть пример Java")  
></details>

><details><summary>Вложенные операторы try</summary>
>
>Всякий раз, когда управление передается блоку оператора try, контекст соответствующего исключения размещается в стеке. Если во вложенном операторе try отсутствует оператор catch
 для перехвата и обработки конкретного исключения, стек развертывается, и проверяется на соответствие оператор catch из внешнего блока оператора try. И так до тех пор, пока не будет найден подходящий оператор catch или не будут исчерпаны все уровни вложенности операторов try. 
 Если подходящий оператор catch не будет найден, то возникшее исключение обработает исполняющая система Java. 
>[Chapter10/NestedTry - Пример применения вложенных операторов try](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/NestedTry.java "Посмотреть пример Java")  
>
>Вложение операторов try может быть не столь очевидным при вызовах методов. Например, вызов метода можно заключить в блок оператора try, а в теле этого метода организовать еще один блок оператора try. В этом случае блок оператора try в теле метода оказывается вложенным во внешний блок оператора try,
 откуда вызывается этот метод. Ниже приведена версия предыдущей программы, где блок вложенного оператора try перемещен в тело метода nesttry(). Эта версия программы выводит такой же результат, как и предыдущая.  
>[Chapter10/MethNestedTry - Операторы try могут быть неявно вложены в вызовы методов](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/MethNestedTry.java "Посмотреть пример Java")
></details>

><details><summary>Оператор throw</summary>
>
>До сих пор в примерах перехватывались только те исключения, которые генерировала исполняющая система Java. Но исключения можно генерировать и непосредственно в прикладной программе, используя оператор throw.  
>Общая форма выглядит следующим образом:   
>```
> throw генерируемый_экземпляр; 
>```
>*Генерируемый_экземпляр* должен быть объектом класса Throwable или производного от него подкласса. Примитивные типы вроде int или char, а также классы, кроме Throwable, например String или Object, нельзя использовать для генерирования исключений. Получить объект класса Throwable
 можно двумя способами, указав соответствующий параметр в операторе саtсh или создав этот объект с помощью операции new.
>
>Поток исполнения программы останавливается сразу же после оператора throw, а все последующие операторы не выполняются. В этом случае ближайший объемлющий блок оператора try проверяется на наличие в нем оператора саtch с совпадающим типом исключения. Если совпадение обнаружено, управление передается этому оператору. В противном случае проверяется следующий внешний
 блок оператора try и т.д. Если же не удастся найти оператор catch, совпадающий с типом исключения, то стандартный обработчик исключений прерывает выполнение программы и выводит результат трассировки стека.  
>
>Эта программа получает две возможности для обработки одной и той же ошибки. Сначала в методе main() устанавливается контекст исключения, затем вызывается метод demoproc(), где задается другой контекст обработки исключения и сразу же генерируется новый экземпляр исключения типа NullPointerException, который перехватывается в следующей строке кода. Затем исключение генерируется повторно.  
>
>  
>[Chapter10/ThrowDemo - Продемонстрировать применение оператора throw](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/ThrowDemo.java "Посмотреть пример Java")
>  
></details>

><details><summary>Оператор throws</summary>
>
>Если метод способен вызвать исключение, которое он сам не обрабатывает, то он должен задать свое поведение таким образом, чтобы вызывающий его код мог обезопасить себя от такого исключения. С этой целью в объявление метода вводится оператор *throws*, где перечисляются типы исключений, которые метод
 может генерировать. Это обязательно для всех исключений, кроме тех, которые относятся к классам *Error* и *RuntimeException* или любым их подклассам. Все остальные исключения, которые может сгенерировать метод, должны быть объявлены в операторе *throws*. Если этого не сделать, то во время компиляции возникнет ошибка.   
>Общая форма объявления метода, которая включает оператор throws:
>```
>тип имя_метода(список_параметров) throws список_исключений
>{
>  // тело метода
>}
>```  
>Здесь *список_исключений* обозначает разделяемый запятыми список исключений, которые метод может сгенерировать.
>[Chapter10/ThrowsDemo - Продемонстрировать throws](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/ThrowsDemo.java "Посмотреть пример Java")
>  
></details>

><details><summary>Оператор finally</summary>
>
>Оператор *finally* образует блок кода, который будет выполнен по завершении блока операторов *try/catch*, но перед следующим за ним кодом. Блок оператора *finally* выполняется независимо от того, сгенерировано исключение или
 нет. Если исключение сгенерировано, блок оператора *finally* выполняется, даже при условии, что ни один из операторов *catch* не совпадает с этим исключением. В любой момент, когда метод собирается возвратить управление вызывающему коду из блока оператора *try/catch* (через необработанное исключение или
 явным образом через оператор return), блок оператора *finally* выполняется перед возвратом управления из метода. Это может быть удобно для закрытия файловых дескрипторов или освобождения других ресурсов, которые были выделены
 в начале метода и должны быть освобождены перед возвратом из него. Указывать оператор *finally* необязательно, но каждому оператору *try* требуется хотя бы один оператор *саtch* или *finally*.
>
>Пример программы, в котором демонстрируются три метода, возвращающих управление разными способами. Но ни в одном из них не пропускается выполнение блока оператора finally.  
>[Chapter10/FinallyDemo - Продемонстрировать применение оператора finally](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/FinallyDemo.java "Посмотреть пример Java")  
>ВАЖНО!!! *Если блок оператора finally связан с блоком оператора try, то блок оператора finally будет выполнен по завершении блока оператора try.*  
>[Chapter10/ExampleException - Продемонстрировать все исключения](https://github.com/aykononov/JavaSchildt/blob/master/Chapter10/ExampleException.java "Посмотреть пример Java")
>
></details>

</details>

<details><summary>ГЛАВА 11. "Многопоточное программирование"</summary>

><details><summary>Многопоточность</summary>
>
>*Многопоточность* - это особая форма многозадачности, которая делит один *процесс* (одну выполняющуюся программу) на несколько *потоков исполнения*.  
>Все *потоки исполнения* выполняются одновременно и каждый *поток* задает отдельный путь исполнения кода.  
>Существуют два отдельных вида многозадачности: многозадачность на основе *процессов* и многозадачность на основе *потоков*.
>  
>
>*Многозадачность на основе процессов* - это средство, которое позволяет одновременно выполнять несколько программ на компьютер.
>*Процессы* являются крупными задачами, каждой из которых требуется свое адресное пространство. Связь между *процессами* ограничена и обходится дорого. Переключение контекста с одного *процесса* на другой также обходится дорого.
>
>*Потоки исполнения* более просты. Они совместно используют одно и то же адресное пространство и один и тот же крупный процесс. Связь между *потоками исполнения* обходится недорого, как, впрочем, и переключение контекста с одного *потока исполнения* на другой.  
>Еще одним преимуществом *многопоточности* является сведение к минимуму времени ожидания.
>
>В *однопоточных* средах прикладной программе приходится ожидать завершения таких задач, прежде чем переходить к следующей задаче, даже если большую часть времени программа простаивает, ожидая ввода.  
>*Многопоточность* помогает сократить простои, поскольку в то время, как *один* поток исполнения ожидает - *другой* может выполняться.
>  
>**Приоритеты потоков**  
>*Приоритет потока исполнения* служит для принятия решения при переходе от одного потока к другому. Это так называемое *переключение контекста*. Правила, которые определяют, когда должно происходить переключение контекста:  
>* *Поток может добровольно уступить управление*. Для этого достаточно
 явно уступить очередь на исполнение, приостановить или блокировать поток на время ожидания ввода-вывода. В этом случае все прочие потоки исполнения проверяются, а ресурсы ЦП передаются потоку, имеющему наибольший приоритет и готовому к выполнению.
>* *Один поток исполнения может быть вытеснен другим, более приоритетным потоком*. В этом случае низкоприоритетный поток исполнения, который не уступает ЦП, просто вытесняется высокоприоритетным потоком,
 независимо от того, что он делает. По существу, высокоприоритетный поток выполняется, как только это ему потребуется. Это так называемая *вытесняющая многозадачность* (или многозадачность с приоритетами).
> 
>**Синхронизация**  
>Если требуется, чтобы два *потока исполнения* взаимодействовали и совместно использовали сложную структуру данных вроде *связного списка*, необходимо исключить возможный конфликт между этими потоками, т.е. предотвратить запись данных в одном *потоке исполнения*, когда в другом *потоке исполнения* выполняется их чтение.
>Для этой цели в Java реализован *монитор*. У каждого объекта имеется свой *неявный монитор*, вход в который осуществляется автоматически, когда для этого объекта вызывается синхронизированный метод. Когда *поток исполнения* находится в теле *синхронизированного метода*, ни один другой *поток исполнения* не может вызвать какой-нибудь другой *синхронизированный метод* для того же самого объекта. Это позволяет писать ясный и краткий многопоточный код, поскольку поддержка синхронизации встроена в сам язык.  
>  
>**Обмен сообщениями**  
>Система *обмена сообщениями* в Java позволяет *потоку исполнения* войти в синхронизированный метод объекта и ожидать до тех пор, пока какой-нибудь другой поток явно не уведомит его об освобождении требующихся ресурсов.
> 
></details>

><details><summary>Класс Thread и Интерфейс Runnable</summary>
>
>Многопоточная система в Java построена на основе класса *Thread*, его методах и дополняющем его Интерфейсе *Runnable*. Класс *Thread* инкапсулирует поток исполнения. Обратиться напрямую к нематериальному состоянию работающего потока исполнения нельзя, поэтому приходится иметь дело с его заместителем - экземпляром класса Thread, который и породил его. Чтобы создать новый *поток исполнения*, следует расширить класс *Thread* или же реализовать интерфейс *Runnable*.
 В классе *Thread* определяется ряд методов, помогающих управлять *потоками исполнения*.
>
>>**Методы управления потоками исполнения из класса Thread**  
>>|Метод      |Название|
>>|:----------|:-------|
>>|getName    |Получает имя потока исполнения|
>>|getPriority|Получает приоритет потока исполнения|
>>|isAlive    |Определяет, выполняется ли поток|
>>|join       |Ожидает завершения потока исполнения|
>>|run        |Задает точку входа в поток исполнения|
>>|sleep      |Приостанавливает выполнение потока на заданное время|
>>|start      |Запускает поток, вызывая ero метод run()|
>
></details>

><details><summary>Главный поток исполнения</summary>
>
>*Главный поток исполнения* создается автоматически при запуске программы, им можно управлять через объект класса Thread. Для этого достаточно получить ссылку на него, вызвав метод currentThread(), который объявляется как открытый и статический (*рublic static*) в классе Thread.  
>Его общая форма выглядит следующим образом:
>```Java
>static Thread currentThread()
>```  
>Этот метод возвращает ссылку на тот поток исполнения, из которого он был вызван. Получив ссылку на *главный поток*, можно управлять им таким же образом, как и любым другим потоком исполнения.  
>[Chapter11/CurrentThreadDemo - Управление главным потоком исполнения](https://github.com/aykononov/JavaSchildt/blob/master/Chapter11/CurrentThreadDemo.java "Посмотреть пример Java")   
>*Группа потоков исполнения* - это структура данных, которая управляет состоянием всей совокупности потоков исполнения в целом.
>
></details>

><details><summary>Создание потока исполнения</summary>
>
>Для создания потока исполнения следует получить экземпляр объекта типа Thread. В языке Java этой цели можно достичь следующими двумя способами:  
>* реализовав интерфейс Runnable;
>* расширив класс Thread.
>
></details>

><details><summary>Реализация интерфейса Runnable</summary>
>
>Самый простой способ создать поток исполнения состоит в том, чтобы объявить класс, реализующий интерфейс Runnable. Этот интерфейс предоставляет абстракцию единицы исполняемого кода. Поток исполнения можно создать из
 объекта любого класса, реализующего интерфейс Runnable. Для реализации интерфейса Runnable в классе должен быть объявлен единственный метод run():  
>```Java
>public void run()
>```
>В теле метода run() определяется код, который, собственно, и составляет новый поток исполнения. Но в методе run() можно также вызывать другие методы, использовать другие классы, объявлять переменные таким же образом, как и в главном
 потоке исполнения. Единственное отличие заключается в том, что в методе run() устанавливается *точка входа* в другой, параллельный поток исполнения в программе. Этот поток исполнения завершится, когда метод run() возвратит управление.
 После создания класса, реализующего интерфейс Runnable, в этом классе следует получить экземпляр объекта типа Thread. Для этой цели в классе Thread определен ряд конструкторов. Тот конструктор, который должен использоваться в данном случае, выглядит в общей форме следующим образом:  
>```Java
>Thread (Runnable объект_потока, String имя_потока)
>```
>В этом конструкторе параметр объект_потока обозначает экземпляр класса, реализующего интерфейс Runnable. Этим определяется место, где начинается выполнение потока. Имя нового потока исполнения передается данному конструктору в качестве параметра имя_потока.
>
>После того как новый поток исполнения будет создан, он не запускается до тех пор, пока не будет вызван метод start(),объявленный в классе Thread. По существу, в методе start() вызывается метод run().  
>```Java
>void start ()
>```  
>Пример программы, где демонстрируется создание и запуск нового потока на выполнение:  
>[Chapter11/Package01/ThreadDemo - Создать второй поток исполнения](https://github.com/aykononov/JavaSchildt/blob/master/Chapter11/Package01/ThreadDemo.java "Посмотреть пример Java")  
>Новый объект класса Thread создается в следующем операторе из конструктора NewThread():  
>```java
>t = new Thread(this, "Демонстрационный поток");
>```  
>Передача ссылки this на текущий объект в первом аргументе данного конструктора означает следующее:  
>в новом потоке исполнения для текущего объекта по ссылке this следует вызвать метод run().  
>Далее вызывается метод start(), в результате чего поток исполнения запускается, начиная с метода run().   
>Это, в свою очередь, приводит к началу цикла for в дочернем потоке исполнения.  
>После вызова метода start() конструктор NewThread() возвращает управление методу main().  
>Возобновляя свое исполнение, главный поток входит в свой цикл for. Далее потоки выполняются параллельно, 
 совместно используя ресурсы процессора в одноядерной системе, вплоть до завершения своих циклов.  
>
></details>

><details><summary>Расширение класса Thread</summary>
>
>Еще один способ создать поток исполнения состоит в том, чтобы сначала объявить класс, расширяющий класс Thread, а затем получить экземпляр этого класса. В расширяющем классе должен быть непременно переопределен метод run(), который является точкой входа в новый поток исполнения. Кроме того, в этом классе
должен быть вызван метод start() для запуска нового потока на исполнение. Ниже приведена версия программы из предыдущего примера, переделенная с учетом расширения класса Thread.  
>[Chapter11/Package02/ExtendThread - Создать второй поток исполнения, расширив класс Thread](https://github.com/aykononov/JavaSchildt/blob/master/Chapter11/Package02/ExtendThread.java "Посмотреть пример Java")  
>Эта версия программы выводит такой же результат, как и предыдущая ее версия ThreadDemo.java.
 Дочерний поток исполнения создается при конструировании объекта класса NewThread, наследующего от класса Thread.
 Обратите внимание на метод super() в классе NewThread. Он вызывает конструктор Thread(), общая форма которого приведена ниже,
 где параметр имя_потока обозначает имя порождаемого потока исполнения.  
>```java
> puЬlic Thread(String имя_потока)
>```
>
></details>

><details><summary>Выбор способа создания потоков исполнения</summary>
>
>В классе Thread определяется ряд методов, которые могут быть переопределены в производных классах. И только один из них должен быть непременно переопределен:
 *метод run()*. Безусловно, этот метод требуется и в том случае, когда реализуется интерфейс Runnable. Многие программирующие на Java считают, что классы
 следует расширять только в том случае, если они должны быть усовершенствованы или каким-то образом видоизменены. Следовательно, если ни один из других методов не переопределяется в классе Thread, то лучше и проще реализовать
 интерфейс Runnable. Кроме того, при реализации интерфейса Runnable класс порождаемого потока исполнения не должен наследовать класс Thread, что освобождает его от наследования другого класса. В конечном счете выбор конкретного
 способа для создания потоков исполнения остается за вами. Тем не менее в примерах, приведенных далее в этой главе, потоки будут создаваться с помощью классов, реализующих интерфейс Runnable.
>
></details>

><details><summary>Создание многих потоков исполнения</summary>
>
>В прикладной программе можно порождать сколько угодно потоков исполнения. Например, в следующей программе создаются три дочерних потока исполнения:  
>[Chapter11/Package03/MultiThreadDemo - Создать несколько потоков исполнения](https://github.com/aykononov/JavaSchildt/blob/master/Chapter11/Package03/MultiThreadDemo.java "Посмотреть пример Java")
>
></details>

><details><summary>Применение методов isAlive() и jоin()</summary>
>
>Чтобы главный поток исполнения завершался последним, метод sleep() вызывался в предыдущих примерах из метода main() с достаточной задержкой, чтобы все дочерние потоки исполнения завершились раньше главного.  
>Это *неудовлетворительное решение*, так как одному потоку исполнения не извеснто, что другой завершился. Определить, был ли поток исполнения завершен, можно двумя способами.
>
>Во-первых для этого потока можно вызвать метод *isAlive()*, определенный в классе Thread. Ниже приведена общая форма этого метода.  
>```java
>final Boolean isAlive()
>```  
>Метод *isAlive()* возвращает логическое значение *true*, если поток, для которого он вызван, еще исполняется. В противном случае он возвращает логическое значение *false*.  
>
>Во-вторых, в классе Thread имеется метод *join()*, который применяется чаще, чем метод *isAlive()*, чтобы дождаться завершения потока исполнения. Ниже приведена общая форма этого метода.  
>```java
>final void join() throws InetrruptedException
>```  
>Этот метод ожидает завершения того потока исполнения, для которого он вызван. Его имя отражает следующий принцип: *вызывающий поток ожидает, когда указанный поток присоединится к нему*. 
>
>Дополнительные формы метода *join()* позволяют указывать максимальный промежуток времени, в течение которого требуется ожидать завершения указанного потока исполнения.  
>Потоки прекращают исполнение после тоrо, как управление возвращается из вызовов метода join().  
>[Chapter11/Package04/DemoJoin - Применить метод join(), чтобы ожидать завершения потоков исполнения](https://github.com/aykononov/JavaSchildt/blob/master/Chapter11/Package04/DemoJoin.java "Посмотреть пример Java")
>
></details>

><details><summary>Приоритеты потоков исполнения</summary>
>
>В прикладной программе можно порождать сколько угодно потоков исполнения. Например, в следующей программе создаются три дочерних потока исполнения:  
>[Chapter11/Package03/MultiThreadDemo - Создать несколько потоков исполнения](https://github.com/aykononov/JavaSchildt/blob/master/Chapter11/Package03/MultiThreadDemo.java "Посмотреть пример Java")
>
></details>



</details>

---
<details><summary>Ключевые моменты...</summary>

**Главное отличие Класса от Интерфейса**  
В Классе могут сохраняться данные cостояния, особенно с помощью переменных  экземпляра, тогда как в Интерфейсе этого сделать нельзя.  

**Множественное наследование**  
Множественное наследование в Java не поддерживается. *Методы с реализацией по умолчанию* предоставляют отчасти возможности, которые обычно связываются с понятием множественного наследования. Например, в одном классе можно реализовать два интерфейса. Если
в каждом из этих интерфейсов предоставляются методы с реализацией по умолчанию, то некоторое поведение наследуется от обоих интерфейсов.
* Приоритет отдается реализации метода в классе над его реализацией в интерфейсе.  
* В тех случаях, когда один интерфейс наследует другой и в обоих интерфейсах определяется общий метод с *реализацией по умолчанию*, предпочтение отдается варианту метода из *наследующего интерфейса*.  

**Исключения**  
*Исключения* в Java необходимы для отслеживания и перехвата ошибок кода. 
>Иерархия исключений:  
>```
>            Throwable
>       -------------------
>      |                   |
>      v                   v
>  Exception             Error
>      |
>      v
>RuntimeException
>```
>
Пример:  
```Java
// Исключения
class ExampleException {
    public static void main (String[] args) {
        try { // Отслеживаем код с возможной ошибкой
            System.out.println("try {... Сгенерируем исключение NullPointerException()");
            throw new NullPointerException(); // Сгенерируем исключение
        } catch (NullPointerException e1) { // Перехватим исключение
            System.out.println("catch() {... Перхватываем и Выводим исключение: " + e1);

            try { // Вложенный блок try
                System.out.println("\ttry {... Сгенерируем исключение SecurityException()");
                throw new SecurityException(); // Сгенерируем исключение
            } catch (Exception e2) { // Перехватим исключение
                System.out.println("\tcatch() {... Перхватываем и Выводим исключение: " + e2);
            }

         } finally { // Выполнить в любом случае после try/catch
            System.out.println("finally {... Этот блок кода выполняется в любом случае после try/catch");
        }
     }
}

/* 
Вывод:
try {... Сгенерируем исключение NullPointerException()
catch() {... Перхватываем и Выводим исключение: java.lang.NullPointerException
	try {... Сгенерируем исключение SecurityException()
	catch() {... Перхватываем и Выводим исключение: java.lang.SecurityException
finally {... Этот блок кода выполняется в любом случае после try/catch
 */
```

</details>

</small>